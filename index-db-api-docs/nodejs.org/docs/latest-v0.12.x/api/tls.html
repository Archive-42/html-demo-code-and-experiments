<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>TLS (SSL) Node.js v0.12.18 Manual &amp; Documentation</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/tls.html">
  <script type="text/javascript" src="//use.typekit.net/mse5tqx.js"></script>
  <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
</head>
<body class="alt apidoc int docs" id="docs">
    <div id="nav">
      <img id="logo" src="assets/logo.svg" alt="node.js">
      <ul>
        <li><a href="http://nodejs.org">Home</a></li>
        <li><a href="http://nodejs.org/download/">Downloads</a></li>
        <li class="active"><a href="http://nodejs.org/documentation/">Docs</a></li>
        <li><a href="http://nodejs.org/community/">Community</a></li>
        <li><a href="http://nodejs.org/about/">About</a></li>
        <li><a href="http://jobs.nodejs.org">Jobs</a></li>
        <li><a href="http://blog.nodejs.org">Blog</a></li>
      </ul>
    </div>
    <div id="content-wrap">
    <div id="content" class="clearfix">
      <div id="column2" class="interior">
        <!--<img src="/images/logo-light.svg" alt="node.js" width="170">-->
        <ul class="docs-nav">
          <li><a href="http://nodejs.org/documentation/">About Docs</a></li>
          <li><a href="http://nodejs.org/documentation/tutorials/">Tutorials</a></li>
          <li><a href="http://nodejs.org/documentation/contributing/">Contributing</a></li>
          <li><a href="http://nodejs.org/documentation/workflow/">Workflow</a></li>
          <li><a href="http://nodejs.org/documentation/localization/">Localization</a></li>
          <li class="active"><a href="http://nodejs.org/api/">API Docs</a></li>
        </ul>
      </div>
        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.12.18 Manual &amp; Documentation</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">Index</a> |
                <a href="all.html">View on single page</a> |
                <a href="tls.json">View as JSON</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>Table of Contents</h2>
            <ul>
<li><a href="#tls_tls_ssl">TLS (SSL)</a><ul>
<li><a href="#tls_protocol_support">Protocol support</a></li>
<li><a href="#tls_client_initiated_renegotiation_attack_mitigation">Client-initiated renegotiation attack mitigation</a></li>
<li><a href="#tls_npn_and_sni">NPN and SNI</a></li>
<li><a href="#tls_perfect_forward_secrecy">Perfect Forward Secrecy</a></li>
<li><a href="#tls_tls_getciphers">tls.getCiphers()</a></li>
<li><a href="#tls_tls_createserver_options_secureconnectionlistener">tls.createServer(options[, secureConnectionListener])</a></li>
<li><a href="#tls_tls_connect_options_callback">tls.connect(options[, callback])</a></li>
<li><a href="#tls_tls_connect_port_host_options_callback">tls.connect(port[, host][, options][, callback])</a></li>
<li><a href="#tls_class_tls_tlssocket">Class: tls.TLSSocket</a></li>
<li><a href="#tls_new_tls_tlssocket_socket_options">new tls.TLSSocket(socket, options)</a></li>
<li><a href="#tls_tls_createsecurecontext_details">tls.createSecureContext(details)</a></li>
<li><a href="#tls_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized">tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized])</a></li>
<li><a href="#tls_class_securepair">Class: SecurePair</a><ul>
<li><a href="#tls_event_secure">Event: &#39;secure&#39;</a></li>
</ul>
</li>
<li><a href="#tls_class_tls_server">Class: tls.Server</a><ul>
<li><a href="#tls_event_secureconnection">Event: &#39;secureConnection&#39;</a></li>
<li><a href="#tls_event_clienterror">Event: &#39;clientError&#39;</a></li>
<li><a href="#tls_event_newsession">Event: &#39;newSession&#39;</a></li>
<li><a href="#tls_event_resumesession">Event: &#39;resumeSession&#39;</a></li>
<li><a href="#tls_event_ocsprequest">Event: &#39;OCSPRequest&#39;</a></li>
<li><a href="#tls_server_listen_port_host_callback">server.listen(port[, host][, callback])</a></li>
<li><a href="#tls_server_close">server.close()</a></li>
<li><a href="#tls_server_address">server.address()</a></li>
<li><a href="#tls_server_addcontext_hostname_context">server.addContext(hostname, context)</a></li>
<li><a href="#tls_server_maxconnections">server.maxConnections</a></li>
<li><a href="#tls_server_connections">server.connections</a></li>
</ul>
</li>
<li><a href="#tls_class_cryptostream">Class: CryptoStream</a><ul>
<li><a href="#tls_cryptostream_byteswritten">cryptoStream.bytesWritten</a></li>
</ul>
</li>
<li><a href="#tls_class_cleartextstream">Class: CleartextStream</a></li>
<li><a href="#tls_class_tls_tlssocket_1">Class: tls.TLSSocket</a><ul>
<li><a href="#tls_event_secureconnect">Event: &#39;secureConnect&#39;</a></li>
<li><a href="#tls_event_ocspresponse">Event: &#39;OCSPResponse&#39;</a></li>
<li><a href="#tls_tlssocket_encrypted">tlsSocket.encrypted</a></li>
<li><a href="#tls_tlssocket_authorized">tlsSocket.authorized</a></li>
<li><a href="#tls_tlssocket_authorizationerror">tlsSocket.authorizationError</a></li>
<li><a href="#tls_tlssocket_getpeercertificate_detailed">tlsSocket.getPeerCertificate([ detailed ])</a></li>
<li><a href="#tls_tlssocket_getcipher">tlsSocket.getCipher()</a></li>
<li><a href="#tls_tlssocket_renegotiate_options_callback">tlsSocket.renegotiate(options, callback)</a></li>
<li><a href="#tls_tlssocket_setmaxsendfragment_size">tlsSocket.setMaxSendFragment(size)</a></li>
<li><a href="#tls_tlssocket_getsession">tlsSocket.getSession()</a></li>
<li><a href="#tls_tlssocket_gettlsticket">tlsSocket.getTLSTicket()</a></li>
<li><a href="#tls_tlssocket_address">tlsSocket.address()</a></li>
<li><a href="#tls_tlssocket_remoteaddress">tlsSocket.remoteAddress</a></li>
<li><a href="#tls_tlssocket_remotefamily">tlsSocket.remoteFamily</a></li>
<li><a href="#tls_tlssocket_remoteport">tlsSocket.remotePort</a></li>
<li><a href="#tls_tlssocket_localaddress">tlsSocket.localAddress</a></li>
<li><a href="#tls_tlssocket_localport">tlsSocket.localPort</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <h1>TLS (SSL)<span><a class="mark" href="#tls_tls_ssl" id="tls_tls_ssl">#</a></span></h1>
<pre class="api_stability_3">Stability: 3 - Stable</pre><p>Use <code>require(&#39;tls&#39;)</code> to access this module.

</p>
<p>The <code>tls</code> module uses OpenSSL to provide Transport Layer Security and/or
Secure Socket Layer: encrypted stream communication.

</p>
<p>TLS/SSL is a public/private key infrastructure. Each client and each
server must have a private key. A private key is created like this:

</p>
<pre><code>openssl genrsa -out ryans-key.pem 2048</code></pre>
<p>All servers and some clients need to have a certificate. Certificates are public
keys signed by a Certificate Authority or self-signed. The first step to
getting a certificate is to create a &quot;Certificate Signing Request&quot; (CSR)
file. This is done with:

</p>
<pre><code>openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem</code></pre>
<p>To create a self-signed certificate with the CSR, do this:

</p>
<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>
<p>Alternatively you can send the CSR to a Certificate Authority for signing.

</p>
<p>(TODO: docs on creating a CA, for now interested users should just look at
<code>test/fixtures/keys/Makefile</code> in the Node source code)

</p>
<p>To create .pfx or .p12, do this:

</p>
<pre><code>openssl pkcs12 -export -in agent5-cert.pem -inkey agent5-key.pem \
    -certfile ca-cert.pem -out agent5.pfx</code></pre>
<ul>
<li><code>in</code>:  certificate</li>
<li><code>inkey</code>: private key</li>
<li><code>certfile</code>: all CA certs concatenated in one file like
<code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code></li>
</ul>
<h2>Protocol support<span><a class="mark" href="#tls_protocol_support" id="tls_protocol_support">#</a></span></h2>
<p>Node.js is compiled with SSLv3 protocol support by default, but these
protocols are <strong>disabled</strong>. They are considered insecure and could be easily
compromised as was shown by <a href="https://access.redhat.com/articles/1232123">CVE-2014-3566</a>. However, in some situations, it
may cause problems with legacy clients/servers (such as Internet Explorer 6).
If you wish to enable SSLv3, run node with the <code>--enable-ssl3</code> flag. In future
versions of Node.js SSLv3 will not be compiled in by default.

</p>
<p>There is a way to force node into using SSLv3 only mode by explicitly
specifying <code>secureProtocol</code> to <code>&#39;SSLv3_method&#39;</code>.

</p>
<p>The default protocol method Node.js uses is <code>SSLv23_method</code> which would be more
accurately named <code>AutoNegotiate_method</code>. This method will try and negotiate
from the highest level down to whatever the client supports.  To provide a
secure default, Node.js (since v0.10.33) explicitly disables the use of SSLv3
by setting the <code>secureOptions</code> to be <code>SSL_OP_NO_SSLv3</code> (again, unless you have
passed <code>--enable-ssl3</code>, or <code>SSLv3_method</code> as <code>secureProtocol</code>).

</p>
<p>If you have set <code>secureOptions</code> to anything, we will not override your
options.

</p>
<p>The ramifications of this behavior change:

</p>
<ul>
<li>If your application is behaving as a secure server, clients who are <code>SSLv3</code>
only will now not be able to appropriately negotiate a connection and will be
refused. In this case your server will emit a <code>clientError</code> event. The error
message will include <code>&#39;wrong version number&#39;</code>.</li>
<li>If your application is behaving as a secure client and communicating with a
server that doesn&#39;t support methods more secure than SSLv3 then your connection
won&#39;t be able to negotiate and will fail. In this case your client will emit a
an <code>error</code> event. The error message will include <code>&#39;wrong version number&#39;</code>.</li>
</ul>
<h2>Client-initiated renegotiation attack mitigation<span><a class="mark" href="#tls_client_initiated_renegotiation_attack_mitigation" id="tls_client_initiated_renegotiation_attack_mitigation">#</a></span></h2>
<!-- type=misc -->

<p>The TLS protocol lets the client renegotiate certain aspects of the TLS session.
Unfortunately, session renegotiation requires a disproportional amount of
server-side resources, which makes it a potential vector for denial-of-service
attacks.

</p>
<p>To mitigate this, renegotiations are limited to three times every 10 minutes. An
error is emitted on the <a href="#tls_class_tls_tlssocket">tls.TLSSocket</a> instance when the threshold is
exceeded. The limits are configurable:

</p>
<ul>
<li><p><code>tls.CLIENT_RENEG_LIMIT</code>: renegotiation limit, default is 3.</p>
</li>
<li><p><code>tls.CLIENT_RENEG_WINDOW</code>: renegotiation window in seconds, default is
10 minutes.</p>
</li>
</ul>
<p>Don&#39;t change the defaults unless you know what you are doing.

</p>
<p>To test your server, connect to it with <code>openssl s_client -connect address:port</code>
and tap <code>R&lt;CR&gt;</code> (that&#39;s the letter <code>R</code> followed by a carriage return) a few
times.


</p>
<h2>NPN and SNI<span><a class="mark" href="#tls_npn_and_sni" id="tls_npn_and_sni">#</a></span></h2>
<!-- type=misc -->

<p>NPN (Next Protocol Negotiation) and SNI (Server Name Indication) are TLS
handshake extensions allowing you:

</p>
<ul>
<li>NPN - to use one TLS server for multiple protocols (HTTP, SPDY)</li>
<li>SNI - to use one TLS server for multiple hostnames with different SSL
certificates.</li>
</ul>
<h2>Perfect Forward Secrecy<span><a class="mark" href="#tls_perfect_forward_secrecy" id="tls_perfect_forward_secrecy">#</a></span></h2>
<!-- type=misc -->

<p>The term &quot;<a href="http://en.wikipedia.org/wiki/Perfect_forward_secrecy">Forward Secrecy</a>&quot; or &quot;Perfect Forward Secrecy&quot; describes a feature of
key-agreement (i.e. key-exchange) methods. Practically it means that even if the
private key of a (your) server is compromised, communication can only be
decrypted by eavesdroppers if they manage to obtain the key-pair specifically
generated for each session.

</p>
<p>This is achieved by randomly generating a key pair for key-agreement on every
handshake (in contrary to the same key for all sessions). Methods implementing
this technique, thus offering Perfect Forward Secrecy, are called &quot;ephemeral&quot;.

</p>
<p>Currently two methods are commonly used to achieve Perfect Forward Secrecy (note
the character &quot;E&quot; appended to the traditional abbreviations):

</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">DHE</a> - An ephemeral version of the Diffie Hellman key-agreement protocol.</li>
<li><a href="https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman">ECDHE</a> - An ephemeral version of the Elliptic Curve Diffie Hellman
key-agreement protocol.</li>
</ul>
<p>Ephemeral methods may have some performance drawbacks, because key generation
is expensive.


</p>
<h2>tls.getCiphers()<span><a class="mark" href="#tls_tls_getciphers" id="tls_tls_getciphers">#</a></span></h2>
<p>Returns an array with the names of the supported SSL ciphers.

</p>
<p>Example:

</p>
<pre><code>var ciphers = tls.getCiphers();
console.log(ciphers); // [&#39;AES128-SHA&#39;, &#39;AES256-SHA&#39;, ...]</code></pre>
<h2>tls.createServer(options[, secureConnectionListener])<span><a class="mark" href="#tls_tls_createserver_options_secureconnectionlistener" id="tls_tls_createserver_options_secureconnectionlistener">#</a></span></h2>
<p>Creates a new <a href="#tls_class_tls_server">tls.Server</a>.  The <code>connectionListener</code> argument is
automatically set as a listener for the <a href="#tls_event_secureconnection">secureConnection</a> event.  The
<code>options</code> object has these possibilities:

</p>
<ul>
<li><p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and
CA certs of the server in PFX or PKCS12 format. (Mutually exclusive with
the <code>key</code>, <code>cert</code> and <code>ca</code> options.)</p>
</li>
<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in
PEM format. (Could be an array of keys). (Required)</p>
</li>
<li><p><code>passphrase</code>: A string of passphrase for the private key or pfx.</p>
</li>
<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the server in
PEM format. (Could be an array of certs). (Required)</p>
</li>
<li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates in PEM
format. If this is omitted several well known &quot;root&quot; CAs will be used,
like VeriSign. These are used to authorize connections.</p>
</li>
<li><p><code>crl</code> : Either a string or list of strings of PEM encoded CRLs (Certificate
Revocation List)</p>
</li>
<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude.</p>
<p>To mitigate <a href="http://blog.ivanristic.com/2011/10/mitigating-the-beast-attack-on-tls.html">BEAST attacks</a> it is recommended that you use this option in
conjunction with the <code>honorCipherOrder</code> option described below to
prioritize the non-CBC cipher.</p>
<p>Defaults to
<code>ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL</code>.
Consult the <a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">OpenSSL cipher list format documentation</a> for details
on the format.</p>
<p><code>ECDHE-RSA-AES128-SHA256</code>, <code>DHE-RSA-AES128-SHA256</code> and
<code>AES128-GCM-SHA256</code> are TLS v1.2 ciphers and used when Node.js is
linked against OpenSSL 1.0.1 or newer, such as the bundled version
of OpenSSL.  Note that it is still possible for a TLS v1.2 client
to negotiate a weaker cipher unless <code>honorCipherOrder</code> is enabled.</p>
<p><code>RC4</code> is used as a fallback for clients that speak on older version of
the TLS protocol.  <code>RC4</code> has in recent years come under suspicion and
should be considered compromised for anything that is truly sensitive.
It is speculated that state-level actors possess the ability to break it.</p>
<p><strong>NOTE</strong>: Previous revisions of this section suggested <code>AES256-SHA</code> as an
acceptable cipher. Unfortunately, <code>AES256-SHA</code> is a CBC cipher and therefore
susceptible to <a href="http://blog.ivanristic.com/2011/10/mitigating-the-beast-attack-on-tls.html">BEAST attacks</a>. Do <em>not</em> use it.</p>
</li>
<li><p><code>ecdhCurve</code>: A string describing a named curve to use for ECDH key agreement
or false to disable ECDH.</p>
<p>Defaults to <code>prime256v1</code>. Consult <a href="http://www.rfc-editor.org/rfc/rfc4492.txt">RFC 4492</a> for more details.</p>
</li>
<li><p><code>dhparam</code>: DH parameter file to use for DHE key agreement. Use
<code>openssl dhparam</code> command to create it. If the file is invalid to
load, it is silently discarded. Its key length should be greater
than or equal to 768 bits, otherwise an error will be thrown.</p>
</li>
<li><p><code>handshakeTimeout</code>: Abort the connection if the SSL/TLS handshake does not
finish in this many milliseconds. The default is 120 seconds.</p>
<p>A <code>&#39;clientError&#39;</code> is emitted on the <code>tls.Server</code> object whenever a handshake
times out.</p>
</li>
<li><p><code>honorCipherOrder</code> : When choosing a cipher, use the server&#39;s preferences
instead of the client preferences.</p>
<p>Although, this option is disabled by default, it is <em>recommended</em> that you
use this option in conjunction with the <code>ciphers</code> option to mitigate
BEAST attacks.</p>
<p>Note: If SSLv2 is used, the server will send its list of preferences to the
client, and the client chooses the cipher.  Support for SSLv2 is disabled
unless node.js was configured with <code>./configure --with-sslv2</code>.</p>
</li>
<li><p><code>requestCert</code>: If <code>true</code> the server will request a certificate from
clients that connect and attempt to verify that certificate. Default:
<code>false</code>.</p>
</li>
<li><p><code>rejectUnauthorized</code>: If <code>true</code> the server will reject any connection
which is not authorized with the list of supplied CAs. This option only
has an effect if <code>requestCert</code> is <code>true</code>. Default: <code>false</code>.</p>
</li>
<li><p><code>checkServerIdentity(servername, cert)</code>: Provide an override for checking
server&#39;s hostname against the certificate. Should return an error if verification
fails. Return <code>undefined</code> if passing.</p>
</li>
<li><p><code>NPNProtocols</code>: An array or <code>Buffer</code> of possible NPN protocols. (Protocols
should be ordered by their priority).</p>
</li>
<li><p><code>SNICallback(servername, cb)</code>: A function that will be called if client
supports SNI TLS extension. Two argument will be passed to it: <code>servername</code>,
and <code>cb</code>. <code>SNICallback</code> should invoke <code>cb(null, ctx)</code>, where <code>ctx</code> is a
SecureContext instance.
(You can use <code>tls.createSecureContext(...)</code> to get proper
SecureContext). If <code>SNICallback</code> wasn&#39;t provided - default callback with
high-level API will be used (see below).</p>
</li>
<li><p><code>sessionTimeout</code>: An integer specifying the seconds after which TLS
session identifiers and TLS session tickets created by the server are
timed out. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_timeout.html">SSL_CTX_set_timeout</a> for more details.</p>
</li>
<li><p><code>ticketKeys</code>: A 48-byte <code>Buffer</code> instance consisting of 16-byte prefix,
16-byte hmac key, 16-byte AES key. You could use it to accept tls session
tickets on multiple instances of tls server.</p>
<p>NOTE: Automatically shared between <code>cluster</code> module workers.</p>
</li>
<li><p><code>sessionIdContext</code>: A string containing an opaque identifier for session
resumption. If <code>requestCert</code> is <code>true</code>, the default is MD5 hash value
generated from command-line. Otherwise, the default is not provided.</p>
</li>
<li><p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a>.</p>
</li>
<li><p><code>secureOptions</code>: Set server options. For example, to disable the SSLv3
protocol set the <code>SSL_OP_NO_SSLv3</code> flag. See <a href="https://www.openssl.org/docs/ssl/SSL_CTX_set_options.html">SSL_CTX_set_options</a>
for all available options.</p>
</li>
</ul>
<p>Here is a simple example echo server:

</p>
<pre><code>var tls = require(&#39;tls&#39;);
var fs = require(&#39;fs&#39;);

var options = {
  key: fs.readFileSync(&#39;server-key.pem&#39;),
  cert: fs.readFileSync(&#39;server-cert.pem&#39;),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

  // This is necessary only if the client uses the self-signed certificate.
  ca: [ fs.readFileSync(&#39;client-cert.pem&#39;) ]
};

var server = tls.createServer(options, function(socket) {
  console.log(&#39;server connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  socket.write(&quot;welcome!\n&quot;);
  socket.setEncoding(&#39;utf8&#39;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&#39;server bound&#39;);
});</code></pre>
<p>Or

</p>
<pre><code>var tls = require(&#39;tls&#39;);
var fs = require(&#39;fs&#39;);

var options = {
  pfx: fs.readFileSync(&#39;server.pfx&#39;),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

};

var server = tls.createServer(options, function(socket) {
  console.log(&#39;server connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  socket.write(&quot;welcome!\n&quot;);
  socket.setEncoding(&#39;utf8&#39;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&#39;server bound&#39;);
});</code></pre>
<p>You can test this server by connecting to it with <code>openssl s_client</code>:


</p>
<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>
<h2>tls.connect(options[, callback])<span><a class="mark" href="#tls_tls_connect_options_callback" id="tls_tls_connect_options_callback">#</a></span></h2>
<h2>tls.connect(port[, host][, options][, callback])<span><a class="mark" href="#tls_tls_connect_port_host_options_callback" id="tls_tls_connect_port_host_options_callback">#</a></span></h2>
<p>Creates a new client connection to the given <code>port</code> and <code>host</code> (old API) or
<code>options.port</code> and <code>options.host</code>. (If <code>host</code> is omitted, it defaults to
<code>localhost</code>.) <code>options</code> should be an object which specifies:

</p>
<ul>
<li><p><code>host</code>: Host the client should connect to</p>
</li>
<li><p><code>port</code>: Port the client should connect to</p>
</li>
<li><p><code>socket</code>: Establish secure connection on a given socket rather than
creating a new socket. If this option is specified, <code>host</code> and <code>port</code>
are ignored.</p>
</li>
<li><p><code>path</code>: Creates unix socket connection to path. If this option is
specified, <code>host</code> and <code>port</code> are ignored.</p>
</li>
<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude.</p>
<p>Defaults to
<code>ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:AES128-GCM-SHA256:HIGH:!RC4:!MD5:!aNULL</code>.
Consult the <a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">OpenSSL cipher list format documentation</a> for details
on the format.</p>
<p>The full list of available ciphers can be obtained via <a href="#tls_tls_getciphers">tls.getCiphers</a>.</p>
<p><code>ECDHE-RSA-AES128-SHA256</code>, <code>DHE-RSA-AES128-SHA256</code> and
<code>AES128-GCM-SHA256</code> are TLS v1.2 ciphers and used when Node.js is
linked against OpenSSL 1.0.1 or newer, such as the bundled version
of OpenSSL.</p>
</li>
<li><p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and
CA certs of the client in PFX or PKCS12 format.</p>
</li>
<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the client in
PEM format. (Could be an array of keys).</p>
</li>
<li><p><code>passphrase</code>: A string of passphrase for the private key or pfx.</p>
</li>
<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the client in
PEM format. (Could be an array of certs).</p>
</li>
<li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates in PEM
format. If this is omitted several well known &quot;root&quot; CAs will be used,
like VeriSign. These are used to authorize connections.</p>
</li>
<li><p><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against
the list of supplied CAs. An <code>&#39;error&#39;</code> event is emitted if verification
fails; <code>err.code</code> contains the OpenSSL error code. Default: <code>true</code>.</p>
</li>
<li><p><code>NPNProtocols</code>: An array of strings or <code>Buffer</code>s containing supported NPN
protocols. <code>Buffer</code>s should have following format: <code>0x05hello0x05world</code>,
where first byte is next protocol name&#39;s length. (Passing array should
usually be much simpler: <code>[&#39;hello&#39;, &#39;world&#39;]</code>.)</p>
</li>
<li><p><code>servername</code>: Servername for SNI (Server Name Indication) TLS extension.</p>
</li>
<li><p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a>.</p>
</li>
<li><p><code>session</code>: A <code>Buffer</code> instance, containing TLS session.</p>
</li>
</ul>
<p>The <code>callback</code> parameter will be added as a listener for the
<a href="#tls_event_secureconnect">&#39;secureConnect&#39;</a> event.

</p>
<p><code>tls.connect()</code> returns a <a href="#tls_class_tls_tlssocket">tls.TLSSocket</a> object.

</p>
<p>Here is an example of a client of echo server as described previously:

</p>
<pre><code>var tls = require(&#39;tls&#39;);
var fs = require(&#39;fs&#39;);

var options = {
  // These are necessary only if using the client certificate authentication
  key: fs.readFileSync(&#39;client-key.pem&#39;),
  cert: fs.readFileSync(&#39;client-cert.pem&#39;),

  // This is necessary only if the server uses the self-signed certificate
  ca: [ fs.readFileSync(&#39;server-cert.pem&#39;) ]
};

var socket = tls.connect(8000, options, function() {
  console.log(&#39;client connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&#39;utf8&#39;);
socket.on(&#39;data&#39;, function(data) {
  console.log(data);
});
socket.on(&#39;end&#39;, function() {
  server.close();
});</code></pre>
<p>Or

</p>
<pre><code>var tls = require(&#39;tls&#39;);
var fs = require(&#39;fs&#39;);

var options = {
  pfx: fs.readFileSync(&#39;client.pfx&#39;)
};

var socket = tls.connect(8000, options, function() {
  console.log(&#39;client connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&#39;utf8&#39;);
socket.on(&#39;data&#39;, function(data) {
  console.log(data);
});
socket.on(&#39;end&#39;, function() {
  server.close();
});</code></pre>
<h2>Class: tls.TLSSocket<span><a class="mark" href="#tls_class_tls_tlssocket" id="tls_class_tls_tlssocket">#</a></span></h2>
<p>Wrapper for instance of <a href="net.html#net_class_net_socket">net.Socket</a>, replaces internal socket read/write
routines to perform transparent encryption/decryption of incoming/outgoing data.

</p>
<h2>new tls.TLSSocket(socket, options)<span><a class="mark" href="#tls_new_tls_tlssocket_socket_options" id="tls_new_tls_tlssocket_socket_options">#</a></span></h2>
<p>Construct a new TLSSocket object from existing TCP socket.

</p>
<p><code>socket</code> is an instance of <a href="net.html#net_class_net_socket">net.Socket</a>

</p>
<p><code>options</code> is an object that might contain following properties:

</p>
<ul>
<li><p><code>secureContext</code>: An optional TLS context object from
 <code>tls.createSecureContext( ... )</code></p>
</li>
<li><p><code>isServer</code>: If true - TLS socket will be instantiated in server-mode</p>
</li>
<li><p><code>server</code>: An optional <a href="net.html#net_class_net_server">net.Server</a> instance</p>
</li>
<li><p><code>requestCert</code>: Optional, see <a href="#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></p>
</li>
<li><p><code>rejectUnauthorized</code>: Optional, see <a href="#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></p>
</li>
<li><p><code>NPNProtocols</code>: Optional, see <a href="#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></p>
</li>
<li><p><code>SNICallback</code>: Optional, see <a href="#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></p>
</li>
<li><p><code>session</code>: Optional, a <code>Buffer</code> instance, containing TLS session</p>
</li>
<li><p><code>requestOCSP</code>: Optional, if <code>true</code> - OCSP status request extension would
be added to client hello, and <code>OCSPResponse</code> event will be emitted on socket
before establishing secure communication</p>
</li>
</ul>
<h2>tls.createSecureContext(details)<span><a class="mark" href="#tls_tls_createsecurecontext_details" id="tls_tls_createsecurecontext_details">#</a></span></h2>
<p>Creates a credentials object, with the optional details being a
dictionary with keys:

</p>
<ul>
<li><code>pfx</code> : A string or buffer holding the PFX or PKCS12 encoded private
key, certificate and CA certificates</li>
<li><code>key</code> : A string holding the PEM encoded private key</li>
<li><code>passphrase</code> : A string of passphrase for the private key or pfx</li>
<li><code>cert</code> : A string holding the PEM encoded certificate</li>
<li><code>ca</code> : Either a string or list of strings of PEM encoded CA
certificates to trust.</li>
<li><code>crl</code> : Either a string or list of strings of PEM encoded CRLs
(Certificate Revocation List)</li>
<li><code>ciphers</code>: A string describing the ciphers to use or exclude.
Consult
<a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
for details on the format.</li>
<li><code>honorCipherOrder</code> : When choosing a cipher, use the server&#39;s preferences
instead of the client preferences. For further details see <code>tls</code> module
documentation.</li>
</ul>
<p>If no &#39;ca&#39; details are given, then node.js will use the default
publicly trusted list of CAs as given in
</p>
<p><a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.


</p>
<h2>tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized])<span><a class="mark" href="#tls_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized" id="tls_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized">#</a></span></h2>
<p>Creates a new secure pair object with two streams, one of which reads/writes
encrypted data, and one reads/writes cleartext data.
Generally the encrypted one is piped to/from an incoming encrypted data stream,
and the cleartext one is used as a replacement for the initial encrypted stream.

</p>
<ul>
<li><p><code>credentials</code>: A secure context object from tls.createSecureContext( ... )</p>
</li>
<li><p><code>isServer</code>: A boolean indicating whether this tls connection should be
opened as a server or a client.</p>
</li>
<li><p><code>requestCert</code>: A boolean indicating whether a server should request a
certificate from a connecting client. Only applies to server connections.</p>
</li>
<li><p><code>rejectUnauthorized</code>: A boolean indicating whether a server should
automatically reject clients with invalid certificates. Only applies to
servers with <code>requestCert</code> enabled.</p>
</li>
</ul>
<p><code>tls.createSecurePair()</code> returns a SecurePair object with <code>cleartext</code> and
<code>encrypted</code> stream properties.

</p>
<p>NOTE: <code>cleartext</code> has the same APIs as <a href="#tls_class_tls_tlssocket">tls.TLSSocket</a>

</p>
<h2>Class: SecurePair<span><a class="mark" href="#tls_class_securepair" id="tls_class_securepair">#</a></span></h2>
<p>Returned by tls.createSecurePair.

</p>
<h3>Event: &#39;secure&#39;<span><a class="mark" href="#tls_event_secure" id="tls_event_secure">#</a></span></h3>
<p>The event is emitted from the SecurePair once the pair has successfully
established a secure connection.

</p>
<p>Similarly to the checking for the server &#39;secureConnection&#39; event,
pair.cleartext.authorized should be checked to confirm whether the certificate
used properly authorized.

</p>
<h2>Class: tls.Server<span><a class="mark" href="#tls_class_tls_server" id="tls_class_tls_server">#</a></span></h2>
<p>This class is a subclass of <code>net.Server</code> and has the same methods on it.
Instead of accepting just raw TCP connections, this accepts encrypted
connections using TLS or SSL.

</p>
<h3>Event: &#39;secureConnection&#39;<span><a class="mark" href="#tls_event_secureconnection" id="tls_event_secureconnection">#</a></span></h3>
<p><code>function (tlsSocket) {}</code>

</p>
<p>This event is emitted after a new connection has been successfully
handshaked. The argument is an instance of <a href="#tls_class_tls_tlssocket">tls.TLSSocket</a>. It has all the
common stream methods and events.

</p>
<p><code>socket.authorized</code> is a boolean value which indicates if the
client has verified by one of the supplied certificate authorities for the
server. If <code>socket.authorized</code> is false, then
<code>socket.authorizationError</code> is set to describe how authorization
failed. Implied but worth mentioning: depending on the settings of the TLS
server, you unauthorized connections may be accepted.
<code>socket.npnProtocol</code> is a string containing selected NPN protocol.
<code>socket.servername</code> is a string containing servername requested with
SNI.


</p>
<h3>Event: &#39;clientError&#39;<span><a class="mark" href="#tls_event_clienterror" id="tls_event_clienterror">#</a></span></h3>
<p><code>function (exception, tlsSocket) { }</code>

</p>
<p>When a client connection emits an &#39;error&#39; event before secure connection is
established - it will be forwarded here.

</p>
<p><code>tlsSocket</code> is the <a href="#tls_class_tls_tlssocket">tls.TLSSocket</a> that the error originated from.


</p>
<h3>Event: &#39;newSession&#39;<span><a class="mark" href="#tls_event_newsession" id="tls_event_newsession">#</a></span></h3>
<p><code>function (sessionId, sessionData, callback) { }</code>

</p>
<p>Emitted on creation of TLS session. May be used to store sessions in external
storage. <code>callback</code> must be invoked eventually, otherwise no data will be
sent or received from secure connection.

</p>
<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.


</p>
<h3>Event: &#39;resumeSession&#39;<span><a class="mark" href="#tls_event_resumesession" id="tls_event_resumesession">#</a></span></h3>
<p><code>function (sessionId, callback) { }</code>

</p>
<p>Emitted when client wants to resume previous TLS session. Event listener may
perform lookup in external storage using given <code>sessionId</code>, and invoke
<code>callback(null, sessionData)</code> once finished. If session can&#39;t be resumed
(i.e. doesn&#39;t exist in storage) one may call <code>callback(null, null)</code>. Calling
<code>callback(err)</code> will terminate incoming connection and destroy socket.

</p>
<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.


</p>
<h3>Event: &#39;OCSPRequest&#39;<span><a class="mark" href="#tls_event_ocsprequest" id="tls_event_ocsprequest">#</a></span></h3>
<p><code>function (certificate, issuer, callback) { }</code>

</p>
<p>Emitted when the client sends a certificate status request. You could parse
server&#39;s current certificate to obtain OCSP url and certificate id, and after
obtaining OCSP response invoke <code>callback(null, resp)</code>, where <code>resp</code> is a
<code>Buffer</code> instance. Both <code>certificate</code> and <code>issuer</code> are a <code>Buffer</code>
DER-representations of the primary and issuer&#39;s certificates. They could be used
to obtain OCSP certificate id and OCSP endpoint url.

</p>
<p>Alternatively, <code>callback(null, null)</code> could be called, meaning that there is no
OCSP response.

</p>
<p>Calling <code>callback(err)</code> will result in a <code>socket.destroy(err)</code> call.

</p>
<p>Typical flow:

</p>
<ol>
<li>Client connects to server and sends <code>OCSPRequest</code> to it (via status info
extension in ClientHello.)</li>
<li>Server receives request and invokes <code>OCSPRequest</code> event listener if present</li>
<li>Server grabs OCSP url from either <code>certificate</code> or <code>issuer</code> and performs an
<a href="http://en.wikipedia.org/wiki/OCSP_stapling">OCSP request</a> to the CA</li>
<li>Server receives <code>OCSPResponse</code> from CA and sends it back to client via
<code>callback</code> argument</li>
<li>Client validates the response and either destroys socket or performs a
handshake.</li>
</ol>
<p>NOTE: <code>issuer</code> could be null, if the certificate is self-signed or if the issuer
is not in the root certificates list. (You could provide an issuer via <code>ca</code>
option.)

</p>
<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.

</p>
<p>NOTE: you may want to use some npm module like <a href="http://npmjs.org/package/asn1.js">asn1.js</a> to parse the
certificates.


</p>
<h3>server.listen(port[, host][, callback])<span><a class="mark" href="#tls_server_listen_port_host_callback" id="tls_server_listen_port_host_callback">#</a></span></h3>
<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.

</p>
<p>See <code>net.Server</code> for more information.


</p>
<h3>server.close()<span><a class="mark" href="#tls_server_close" id="tls_server_close">#</a></span></h3>
<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>&#39;close&#39;</code>
event.

</p>
<h3>server.address()<span><a class="mark" href="#tls_server_address" id="tls_server_address">#</a></span></h3>
<p>Returns the bound address, the address family name and port of the
server as reported by the operating system.  See <a href="net.html#net_server_address">net.Server.address()</a> for
more information.

</p>
<h3>server.addContext(hostname, context)<span><a class="mark" href="#tls_server_addcontext_hostname_context" id="tls_server_addcontext_hostname_context">#</a></span></h3>
<p>Add secure context that will be used if client request&#39;s SNI hostname is
matching passed <code>hostname</code> (wildcards can be used). <code>context</code> can contain
<code>key</code>, <code>cert</code>, <code>ca</code> and/or any other properties from <code>tls.createSecureContext</code>
<code>options</code> argument.

</p>
<h3>server.maxConnections<span><a class="mark" href="#tls_server_maxconnections" id="tls_server_maxconnections">#</a></span></h3>
<p>Set this property to reject connections when the server&#39;s connection count
gets high.

</p>
<h3>server.connections<span><a class="mark" href="#tls_server_connections" id="tls_server_connections">#</a></span></h3>
<p>The number of concurrent connections on the server.


</p>
<h2>Class: CryptoStream<span><a class="mark" href="#tls_class_cryptostream" id="tls_class_cryptostream">#</a></span></h2>
<pre class="api_stability_0">Stability: 0 - Deprecated. Use tls.TLSSocket instead.</pre><p>This is an encrypted stream.

</p>
<h3>cryptoStream.bytesWritten<span><a class="mark" href="#tls_cryptostream_byteswritten" id="tls_cryptostream_byteswritten">#</a></span></h3>
<p>A proxy to the underlying socket&#39;s bytesWritten accessor, this will return
the total bytes written to the socket, <em>including the TLS overhead</em>.

</p>
<h2>Class: CleartextStream<span><a class="mark" href="#tls_class_cleartextstream" id="tls_class_cleartextstream">#</a></span></h2>
<p>The CleartextStream class in Node.js version v0.10.x (and prior) has been
deprecated and removed.

</p>
<h2>Class: tls.TLSSocket<span><a class="mark" href="#tls_class_tls_tlssocket_1" id="tls_class_tls_tlssocket_1">#</a></span></h2>
<p>This is a wrapped version of <a href="net.html#net_class_net_socket">net.Socket</a> that does transparent encryption
of written data and all required TLS negotiation.

</p>
<p>This instance implements a duplex <a href="stream.html#stream_stream">Stream</a> interfaces.  It has all the
common stream methods and events.

</p>
<h3>Event: &#39;secureConnect&#39;<span><a class="mark" href="#tls_event_secureconnect" id="tls_event_secureconnect">#</a></span></h3>
<p>This event is emitted after a new connection has been successfully handshaked.
The listener will be called no matter if the server&#39;s certificate was
authorized or not. It is up to the user to test <code>tlsSocket.authorized</code>
to see if the server certificate was signed by one of the specified CAs.
If <code>tlsSocket.authorized === false</code> then the error can be found in
<code>tlsSocket.authorizationError</code>. Also if NPN was used - you can check
<code>tlsSocket.npnProtocol</code> for negotiated protocol.

</p>
<h3>Event: &#39;OCSPResponse&#39;<span><a class="mark" href="#tls_event_ocspresponse" id="tls_event_ocspresponse">#</a></span></h3>
<p><code>function (response) { }</code>

</p>
<p>This event will be emitted if <code>requestOCSP</code> option was set. <code>response</code> is a
buffer object, containing server&#39;s OCSP response.

</p>
<p>Traditionally, the <code>response</code> is a signed object from the server&#39;s CA that
contains information about server&#39;s certificate revocation status.

</p>
<h3>tlsSocket.encrypted<span><a class="mark" href="#tls_tlssocket_encrypted" id="tls_tlssocket_encrypted">#</a></span></h3>
<p>Static boolean value, always <code>true</code>. May be used to distinguish TLS sockets
from regular ones.

</p>
<h3>tlsSocket.authorized<span><a class="mark" href="#tls_tlssocket_authorized" id="tls_tlssocket_authorized">#</a></span></h3>
<p>A boolean that is <code>true</code> if the peer certificate was signed by one of the
specified CAs, otherwise <code>false</code>

</p>
<h3>tlsSocket.authorizationError<span><a class="mark" href="#tls_tlssocket_authorizationerror" id="tls_tlssocket_authorizationerror">#</a></span></h3>
<p>The reason why the peer&#39;s certificate has not been verified. This property
becomes available only when <code>tlsSocket.authorized === false</code>.

</p>
<h3>tlsSocket.getPeerCertificate([ detailed ])<span><a class="mark" href="#tls_tlssocket_getpeercertificate_detailed" id="tls_tlssocket_getpeercertificate_detailed">#</a></span></h3>
<p>Returns an object representing the peer&#39;s certificate. The returned object has
some properties corresponding to the field of the certificate. If <code>detailed</code>
argument is <code>true</code> - the full chain with <code>issuer</code> property will be returned,
if <code>false</code> - only the top certificate without <code>issuer</code> property.

</p>
<p>Example:

</p>
<pre><code>{ subject:
   { C: &#39;UK&#39;,
     ST: &#39;Acknack Ltd&#39;,
     L: &#39;Rhys Jones&#39;,
     O: &#39;node.js&#39;,
     OU: &#39;Test TLS Certificate&#39;,
     CN: &#39;localhost&#39; },
  issuerInfo:
   { C: &#39;UK&#39;,
     ST: &#39;Acknack Ltd&#39;,
     L: &#39;Rhys Jones&#39;,
     O: &#39;node.js&#39;,
     OU: &#39;Test TLS Certificate&#39;,
     CN: &#39;localhost&#39; },
  issuer:
   { ... another certificate ... },
  raw: &lt; RAW DER buffer &gt;,
  valid_from: &#39;Nov 11 09:52:22 2009 GMT&#39;,
  valid_to: &#39;Nov  6 09:52:22 2029 GMT&#39;,
  fingerprint: &#39;2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF&#39;,
  serialNumber: &#39;B9B0D332A1AA5635&#39; }</code></pre>
<p>If the peer does not provide a certificate, it returns <code>null</code> or an empty
object.

</p>
<h3>tlsSocket.getCipher()<span><a class="mark" href="#tls_tlssocket_getcipher" id="tls_tlssocket_getcipher">#</a></span></h3>
<p>Returns an object representing the cipher name and the SSL/TLS
protocol version of the current connection.

</p>
<p>Example:
{ name: &#39;AES256-SHA&#39;, version: &#39;TLSv1/SSLv3&#39; }

</p>
<p>See SSL_CIPHER_get_name() and SSL_CIPHER_get_version() in
<a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS">http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS</a> for more
information.

</p>
<h3>tlsSocket.renegotiate(options, callback)<span><a class="mark" href="#tls_tlssocket_renegotiate_options_callback" id="tls_tlssocket_renegotiate_options_callback">#</a></span></h3>
<p>Initiate TLS renegotiation process. The <code>options</code> may contain the following
fields: <code>rejectUnauthorized</code>, <code>requestCert</code> (See <a href="#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a>
for details). <code>callback(err)</code> will be executed with <code>null</code> as <code>err</code>,
once the renegotiation is successfully completed.

</p>
<p>NOTE: Can be used to request peer&#39;s certificate after the secure connection
has been established.

</p>
<p>ANOTHER NOTE: When running as the server, socket will be destroyed
with an error after <code>handshakeTimeout</code> timeout.

</p>
<h3>tlsSocket.setMaxSendFragment(size)<span><a class="mark" href="#tls_tlssocket_setmaxsendfragment_size" id="tls_tlssocket_setmaxsendfragment_size">#</a></span></h3>
<p>Set maximum TLS fragment size (default and maximum value is: <code>16384</code>, minimum
is: <code>512</code>). Returns <code>true</code> on success, <code>false</code> otherwise.

</p>
<p>Smaller fragment size decreases buffering latency on the client: large
fragments are buffered by the TLS layer until the entire fragment is received
and its integrity is verified; large fragments can span multiple roundtrips,
and their processing can be delayed due to packet loss or reordering. However,
smaller fragments add extra TLS framing bytes and CPU overhead, which may
decrease overall server throughput.

</p>
<h3>tlsSocket.getSession()<span><a class="mark" href="#tls_tlssocket_getsession" id="tls_tlssocket_getsession">#</a></span></h3>
<p>Return ASN.1 encoded TLS session or <code>undefined</code> if none was negotiated. Could
be used to speed up handshake establishment when reconnecting to the server.

</p>
<h3>tlsSocket.getTLSTicket()<span><a class="mark" href="#tls_tlssocket_gettlsticket" id="tls_tlssocket_gettlsticket">#</a></span></h3>
<p>NOTE: Works only with client TLS sockets. Useful only for debugging, for
session reuse provide <code>session</code> option to <code>tls.connect</code>.

</p>
<p>Return TLS session ticket or <code>undefined</code> if none was negotiated.

</p>
<h3>tlsSocket.address()<span><a class="mark" href="#tls_tlssocket_address" id="tls_tlssocket_address">#</a></span></h3>
<p>Returns the bound address, the address family name and port of the
underlying socket as reported by the operating system. Returns an
object with three properties, e.g.
<code>{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code>

</p>
<h3>tlsSocket.remoteAddress<span><a class="mark" href="#tls_tlssocket_remoteaddress" id="tls_tlssocket_remoteaddress">#</a></span></h3>
<p>The string representation of the remote IP address. For example,
<code>&#39;74.125.127.100&#39;</code> or <code>&#39;2001:4860:a005::68&#39;</code>.

</p>
<h3>tlsSocket.remoteFamily<span><a class="mark" href="#tls_tlssocket_remotefamily" id="tls_tlssocket_remotefamily">#</a></span></h3>
<p>The string representation of the remote IP family. <code>&#39;IPv4&#39;</code> or <code>&#39;IPv6&#39;</code>.

</p>
<h3>tlsSocket.remotePort<span><a class="mark" href="#tls_tlssocket_remoteport" id="tls_tlssocket_remoteport">#</a></span></h3>
<p>The numeric representation of the remote port. For example, <code>443</code>.

</p>
<h3>tlsSocket.localAddress<span><a class="mark" href="#tls_tlssocket_localaddress" id="tls_tlssocket_localaddress">#</a></span></h3>
<p>The string representation of the local IP address.

</p>
<h3>tlsSocket.localPort<span><a class="mark" href="#tls_tlssocket_localport" id="tls_tlssocket_localport">#</a></span></h3>
<p>The numeric representation of the local port.

</p>

          </div>
        </div>
    </div>
    </div>
    <div id="footer">
      <div class="foot-1">
        <a href="http://www.joyent.com"><h5>The Node.js Project is Sponsored by</h5>
        <img src="assets/joyent-footer.svg" width="200">
        <p class="tag">Production Node +<br>High Performance Infrastructure</p></a>
        <a href="https://my.joyent.com/landing/signup/701800000015696" class="button getstarted">Get Started</a>
      </div>
      <div class="foot-2">
        <div class="foot-nav">
          <ul>
            <li><a href="http://nodejs.org/download/">Downloads</a></li>
          </ul>
          <ul>
            <li><a href="http://nodejs.org/documentation/">Documentation</a></li>
            <li><a href="http://nodejs.org/api/">API Docs</a></li>
            <li><a href="http://nodejs.org/documentation/tutorials/">Tutorials</a></li>
            <li><a href="http://nodejs.org/documentation/localization/">Localization</a></li>
          </ul>
          <ul>
            <li><a href="http://nodejs.org/community/">Community</a></li>
            <li><a href="https://github.com/joyent/node/issues">Github Issues</a></li>
            <li><a href="http://groups.google.com/group/nodejs">Mailing List</a></li>
            <li><a href="http://webchat.freenode.net/?channels=node.js">IRC</a></li>
            <li><a href="https://twitter.com/nodejs">Twitter</a></li>
          </ul>
          <ul>
            <li><a href="http://nodejs.org/about/">About</a></li>
            <li><a href="http://nodejs.org/about/organization/">Organization</a></li>
            <li><a href="http://nodejs.org/about/core-team/">Core Team</a></li>
            <li><a href="http://nodejs.org/about/resources/">Resources</a></li>
          </ul>
          <ul>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
          </ul>
        </div>
        <p class="copyright">Copyright 2014 <a href="http://joyent.com/">Joyent, Inc</a>, Node.js is a <a href="https://nodejs.org/images/trademark-policy.pdf">trademark</a> of Joyent, Inc. <a href="https://raw.github.com/joyent/node/v0.12.18/LICENSE">View license</a>.</p>
      </div>
    </div>

  <script src="/sh_main.js"></script>
  <script src="/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
  <script>
    window._gaq = [['_setAccount', 'UA-10874194-2'], ['_trackPageview']];
    (function(d, t) {
      var g = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      g.src = '//www.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g, s);
    }(document, 'script'));
  </script>
</body>
</html>

