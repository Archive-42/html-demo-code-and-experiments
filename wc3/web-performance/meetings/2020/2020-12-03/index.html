<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_o11n5h6c4hdo-6{list-style-type:none}ul.lst-kix_o11n5h6c4hdo-5{list-style-type:none}ul.lst-kix_o11n5h6c4hdo-4{list-style-type:none}ul.lst-kix_o11n5h6c4hdo-3{list-style-type:none}ul.lst-kix_o11n5h6c4hdo-8{list-style-type:none}ul.lst-kix_o11n5h6c4hdo-7{list-style-type:none}ul.lst-kix_grxvbm9mow7q-0{list-style-type:none}.lst-kix_grxvbm9mow7q-6>li:before{content:"\0025cf  "}ul.lst-kix_grxvbm9mow7q-2{list-style-type:none}.lst-kix_grxvbm9mow7q-7>li:before{content:"\0025cb  "}ul.lst-kix_grxvbm9mow7q-1{list-style-type:none}ul.lst-kix_o11n5h6c4hdo-2{list-style-type:none}ul.lst-kix_grxvbm9mow7q-4{list-style-type:none}.lst-kix_grxvbm9mow7q-8>li:before{content:"\0025a0  "}ul.lst-kix_o11n5h6c4hdo-1{list-style-type:none}ul.lst-kix_grxvbm9mow7q-3{list-style-type:none}ul.lst-kix_o11n5h6c4hdo-0{list-style-type:none}ul.lst-kix_grxvbm9mow7q-6{list-style-type:none}ul.lst-kix_grxvbm9mow7q-5{list-style-type:none}ul.lst-kix_grxvbm9mow7q-8{list-style-type:none}.lst-kix_o11n5h6c4hdo-7>li:before{content:"\0025cb  "}ul.lst-kix_grxvbm9mow7q-7{list-style-type:none}.lst-kix_o11n5h6c4hdo-6>li:before{content:"\0025cf  "}.lst-kix_o11n5h6c4hdo-8>li:before{content:"\0025a0  "}.lst-kix_o11n5h6c4hdo-0>li:before{content:"\0025cf  "}.lst-kix_o11n5h6c4hdo-2>li:before{content:"\0025a0  "}ul.lst-kix_bcgil7r6cku9-4{list-style-type:none}.lst-kix_o11n5h6c4hdo-3>li:before{content:"\0025cf  "}.lst-kix_o11n5h6c4hdo-4>li:before{content:"\0025cb  "}ul.lst-kix_bcgil7r6cku9-3{list-style-type:none}ul.lst-kix_bcgil7r6cku9-6{list-style-type:none}ul.lst-kix_bcgil7r6cku9-5{list-style-type:none}ul.lst-kix_bcgil7r6cku9-8{list-style-type:none}.lst-kix_o11n5h6c4hdo-5>li:before{content:"\0025a0  "}ul.lst-kix_bcgil7r6cku9-7{list-style-type:none}.lst-kix_bcgil7r6cku9-8>li:before{content:"\0025a0  "}.lst-kix_bcgil7r6cku9-6>li:before{content:"\0025cf  "}.lst-kix_bcgil7r6cku9-7>li:before{content:"\0025cb  "}.lst-kix_grxvbm9mow7q-5>li:before{content:"\0025a0  "}.lst-kix_grxvbm9mow7q-4>li:before{content:"\0025cb  "}.lst-kix_o11n5h6c4hdo-1>li:before{content:"\0025cb  "}.lst-kix_grxvbm9mow7q-2>li:before{content:"\0025a0  "}.lst-kix_bcgil7r6cku9-0>li:before{content:"\0025cf  "}.lst-kix_grxvbm9mow7q-1>li:before{content:"\0025cb  "}.lst-kix_grxvbm9mow7q-3>li:before{content:"\0025cf  "}.lst-kix_bcgil7r6cku9-2>li:before{content:"\0025a0  "}.lst-kix_bcgil7r6cku9-3>li:before{content:"\0025cf  "}.lst-kix_bcgil7r6cku9-4>li:before{content:"\0025cb  "}.lst-kix_grxvbm9mow7q-0>li:before{content:"\0025cf  "}.lst-kix_bcgil7r6cku9-5>li:before{content:"\0025a0  "}ul.lst-kix_bcgil7r6cku9-0{list-style-type:none}ul.lst-kix_bcgil7r6cku9-2{list-style-type:none}ul.lst-kix_bcgil7r6cku9-1{list-style-type:none}.lst-kix_bcgil7r6cku9-1>li:before{content:"\0025cb  "}ol{margin:0;padding:0}table td,table th{padding:0}.c0{margin-left:36pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c7{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c12{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#0000ee;text-decoration:underline}.c8{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c11{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c6{margin-left:72pt;padding-left:0pt}.c4{padding:0;margin:0}.c9{color:inherit;text-decoration:inherit}.c10{height:11pt}.c2{font-weight:700}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c11"><div><p class="c3 c10"><span class="c1"></span></p></div><h2 class="c7" id="h.fzyyrkbl5unw"><span class="c5">Participants</span></h2><p class="c3"><span>Nic Jansma, Yoav Weiss, David Bokan, Michal Mocny, Sean Feng, Nicol&aacute;s Pe&ntilde;a, Michelle Vu, Annie Sullivan, Steven Bougon, </span><span class="c12"><a class="c9" href="mailto:carine@w3.org">Carine Bournez</a></span><span class="c1">, Phil Walton</span></p><h2 class="c7" id="h.2gag1x5w9yt3"><span class="c5">Next Call </span></h2><p class="c3"><span class="c1">January 7th, skipping the pre-holidays meetings</span></p><p class="c3 c10"><span class="c1"></span></p><h2 class="c7" id="h.4kvkvxnse558"><span class="c8"><a class="c9" href="https://www.google.com/url?q=https://docs.google.com/presentation/d/1_QFqSPtnxWLfiF1EiIKmgiSnJ69KvMh-_ZY70Ia8-Bs/edit?usp%3Dsharing&amp;sa=D&amp;ust=1608566435063000&amp;usg=AOvVaw0DFMNkoDQLf-KIorD5aSB-">Page Visibility &amp; Transient States</a></span><span class="c5">&nbsp;- David Bokan</span></h2><ul class="c4 lst-kix_grxvbm9mow7q-0 start"><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Hoping to reach the right people about prerendering and related visibility state</span></li><li class="c0"><span>&hellip; </span><span style="overflow: hidden;<b> display</b>: inline-block;<b> margin</b>: 0.00px 0.00px;<b> border</b>: 0.00px solid #000000;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);<b> width</b>: 624.00px;<b> height</b>: 337.33px;"><img alt="" src="images/image1.png" style="width: 624.00px;<b> height</b>: 337.33px; margin-left: 0.00px; margin-top: 0.00px;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></li><li class="c0"><span class="c1">... Want to expose a bit about if you&rsquo;re in a prerendering browsing context</span></li><li class="c0"><span class="c1">... Surveyed current use of visibility state, looked through HA and sampled pages</span></li><li class="c0"><span class="c1">... Looked over top 100K using Chrome ClusterTelemetry, to find pages that change content based on visibility state</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: What did you look at to determine different?</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Looked at textual differences between the versions, there was some noise, so required some manual inspection to find &ldquo;real&rdquo; differences</span></li><li class="c0"><span class="c1">... Manually looked at a couple hundred pages</span></li><li class="c0"><span class="c1">... Use cases broke down to 5 buckets: video/animations, deferred fetch of images and large resources, ads+analytics, server side logic (e.g. chatbots), as well as a &ldquo;termination signal&rdquo; to store state.</span></li><li class="c0"><span class="c1">... Why not bring back the &ldquo;prerender&rdquo; state?</span></li></ul><ul class="c4 lst-kix_grxvbm9mow7q-1 start"><li class="c3 c6"><span class="c1">Portals would be a prerendered page that will be visible, so prerender and visible won&rsquo;t be mutually exclusive</span></li><li class="c3 c6"><span class="c1">It&rsquo;s also not mutually exclusive with hidden, and some uses can break, because people don&rsquo;t think about prerender as hidden. Also less ergonomic.</span></li><li class="c3 c6"><span class="c1">Plenty of examples of pages that assume that there are only 2 visibility states.</span></li></ul><ul class="c4 lst-kix_grxvbm9mow7q-0"><li class="c0"><span style="overflow: hidden;<b> display</b>: inline-block;<b> margin</b>: 0.00px 0.00px;<b> border</b>: 0.00px solid #000000;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);<b> width</b>: 624.00px;<b> height</b>: 253.33px;"><img alt="" src="images/image2.png" style="width: 624.00px;<b> height</b>: 253.33px; margin-left: 0.00px; margin-top: 0.00px;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></li><li class="c0"><span class="c1">... Currently used as a termination signal - OS might kill you</span></li><li class="c0"><span class="c1">... Tab and App switcher - say that it&rsquo;s &ldquo;hidden&rdquo; but expect the page to look &ldquo;alive&rdquo;. </span></li><li class="c0"><span class="c1">... The new prerendering bit doesn&rsquo;t change the status quo, but doesn&rsquo;t make things worse.</span></li><li class="c0"><span class="c1">... When entering into a portal, we would want to save state, so having an explicit state for this seems like a better solution than just relying on visibility</span></li><li class="c0"><span class="c1">... Feedback?</span></li><li class="c0"><span class="c2">Npm</span><span class="c1"><b></b>: Like the idea of separating prerendering from visibility state, wondering if we thought about exposing a previous prerendering state to the script. e.g. for visibility state, if you load too late, you might miss the state happened.</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: &ldquo;have I ever been prerendered?&rdquo; Haven&rsquo;t looked too closely into that</span></li><li class="c0"><span class="c2">Npm</span><span class="c1"><b></b>: Presented a solution for visibility state where we&rsquo;d buffer the previous history, and give you the previous state. Seems like we&rsquo;d need both this and the observer, because some use cases require quick reaction. For performance tracking it&rsquo;s fine to just use the observer.</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: I&rsquo;d have to consider that</span></li><li class="c0"><span class="c1">...: Wasn&rsquo;t sure if it&rsquo;s necessary for the prerendering case</span></li><li class="c0"><span class="c2">Nic</span><span class="c1"><b></b>: For analytics knowing if a page was loaded as prerendered seems critical. Affects characteristics of the page. &nbsp;Would be good to have that bucket.</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: The reason I thought this is less of an issue is because for portals that the only way you can load it through prerendered</span></li><li class="c0"><span class="c2">Npm</span><span class="c1"><b></b>: Doesn&rsquo;t Safari already prerender in the URL bar? Presumably, you&rsquo;d want that to also happen through this API</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: App switcher is a case. Maybe don&rsquo;t need a user gesture.</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: Excellent documentation! Like Nicol&aacute;s, I like the separate of this state from visibility. &nbsp;Always thought of this as &ldquo;non interactive&rdquo;. Is the prerendering signal broadly necessary to know, or specific to loading conditions in portal context</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Broader than portals. RE interactive, do you consider a background tab interactive?</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: No. Currently you&rsquo;re either interactive and visible or not. But there are cases where one is true but not the other.</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: For analytics, if it loads into a background tab, it&rsquo;s a live page, but the user haven&rsquo;t intentionally navigated to the page.</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: If a tab has loaded in the background from the initial link?</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Today we want the analytics scripts to work, but not do that if the link was just prerendered by the browser.</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: You would still have the visibility signal. &nbsp;Is this true that analytics want to report it?</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Ads want to report it, but note that the page is visible. But the page was &ldquo;intentionally loaded&rdquo;</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: Second question - Portals &quot;adopt&quot;, could go from prerender to visible back to prerender</span></li><li class="c0"><span class="c1">... Does it make sense to go back to &ldquo;prerendering&rdquo; mode?</span></li><li class="c0"><span class="c1">... Exiting prerender seems like something you should be able to do once</span></li><li class="c0"><span class="c1">... Even if portal adopt, is it more like a prerender or BFCache?</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Restricted portal has the same restrictions</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: Feels more like &ldquo;non interactive&rdquo;</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Couple of overlapping meanings. Find &ldquo;prerendering&rdquo; easier to think about, but maybe not the right name if put back into the portal</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: Similar for app switcher. Calling it &ldquo;prerendered&rdquo; feels awkward. Wanted to see if this is specific to prerendering or broader</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Background page seems particularly tricky to me</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: Does seem like an awkward matrix. &nbsp;Could they would have visibility hidden</span></li><li class="c0"><span class="c2">Yoav</span><span class="c1"><b></b>: Background page would be hidden but interactive. &nbsp;Interactive is not the right word, but is &quot;alive&quot;</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Something that the user is likely to interact with</span></li><li class="c0"><span class="c2">Npm</span><span class="c1"><b></b>: Is the main use case to track &ldquo;intentionality&rdquo;?</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Think so. Intentionality and server side. Other cases captured by &ldquo;visible&rdquo;</span></li><li class="c0"><span class="c2">Npm</span><span>:</span><span class="c1">&nbsp;Do you really need moving back to &ldquo;unintentional&rdquo;?</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Portals use case - carousel of articles but want to move back to the previous state</span></li><li class="c0"><span class="c2">Npm</span><span class="c1"><b></b>: Portal that takes over and goes back to portal?</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Yeah, not quite a navigation but is similar. But the active page might become a portal</span></li><li class="c0"><span class="c2">Yoav</span><span class="c1"><b></b>: Mentioned the &quot;about to terminate&quot; case, doesn&#39;t work in many edge cases. &nbsp;Think is to add another signal?</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Somewhat related. Wanted to not make the situation worse than it is. Using the visibility state is not great. The right path is not a state, but an event and the browser can dispatch that event when it wants. Seems cleaner from a semantics perspective</span></li><li class="c0"><span class="c1">... Today on Android you don&#39;t get any functionality from OS in app switcher, but in the next release, we can dispatch it later</span></li><li class="c0"><span class="c2">Yoav</span><span class="c1"><b></b>: Makes sense, main hurdle is avoiding the XKCD situation where we have 17 dismissive events and now we&#39;re adding an 18th</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Worried about that, but hidden would mostly still work, and cases where it doesn&rsquo;t</span></li><li class="c0"><span class="c2">Npm</span><span class="c1"><b></b>: Not sure developers actually follow our advice, because visible is not reliable. E.g. reporting at &ldquo;onload&rdquo;</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: I think some of the reliability is due to implementation, and disagreements</span></li><li class="c0"><span class="c1">... With this new mode, I wonder if we can say to always use this</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: The idea that a new event would be syntactic sugar to &ldquo;you entered hidden or prerender&rdquo;</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: willkillproc will not be reliable, so not sure that the suggestion on native is to trust that signal</span></li><li class="c0"><span class="c1">... Visibility or prerendering seems better</span></li><li class="c0"><span class="c1">... Transition would be easier</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: Seems easier than telling people to switch off the stuff their already doing</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: BFcache is entirely different</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: A BFcache page won&rsquo;t be in this state. It&rsquo;s completely frozen, but current events are better</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: Until we get previews when hovering the back button</span></li><li class="c0"><span class="c2">David</span><span class="c1"><b></b>: If we get there, that would be &ldquo;prerendering&rdquo;. So it would just work</span></li><li class="c0"><span class="c2">Npm</span><span class="c1"><b></b>: But standalone BFCache won&rsquo;t have state</span></li></ul><h2 class="c7" id="h.clz0ffx88kdt"><span class="c8"><a class="c9" href="https://www.google.com/url?q=https://github.com/w3c/resource-timing/issues/238&amp;sa=D&amp;ust=1608566435074000&amp;usg=AOvVaw3qmASUH86_XsBHllK6_rbp">transferSize might reveal HttpOnly cookies</a></span></h2><ul class="c4 lst-kix_grxvbm9mow7q-0"><li class="c0"><span class="c2">Yoav</span><span class="c1"><b></b>: Current definition (transferSize-encodedBodySize) gives size of headers, which reveals cookie size.</span></li><li class="c0"><span class="c1">... Bad regardless of TAO because we don&#39;t want to reveal even in same origin context</span></li><li class="c0"><span class="c1">... We should define that transferSize does not include cookies</span></li><li class="c0"><span class="c2">Nicol&aacute;s</span><span class="c1"><b></b>: What would be use cases for knowing header sizes outside of cookies. Sites sending large headers?</span></li><li class="c0"><span class="c2">Nic</span><span class="c1"><b></b>: Yeah we use that, but cookies are a large part of that</span></li><li class="c0"><span class="c2">Npm</span><span class="c1"><b></b>: If you can&#39;t do the cookie part, it&#39;s a half-baked solution</span></li><li class="c0"><span class="c2">Yoav</span><span class="c1"><b></b>: I could think of properties sending debugging information</span></li><li class="c0"><span class="c2">Nic</span><span class="c1"><b></b>: We independently report transferSize and encodedBodySize. Customers could do that. But no specific reports that flag that. Not sure if there&rsquo;s been specific analysis related to that. We generally report total transferSize for &ldquo;page weight&rdquo;.</span></li><li class="c0"><span class="c1">... If we were to remove cookies from transferSize, that could cause some confusion. Until all browser are doing that. &nbsp;Could we flag if headers are included or not?</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: Is it not the case that on H2 the headers are compressed</span></li><li class="c0"><span class="c2">Yoav</span><span class="c1"><b></b>: They are compressed in some way. &nbsp;We could say this response&#39;s headers took this many bytes, outside of the raw sizes.</span></li><li class="c0"><span class="c1">... At the same time, if we don&#39;t have a clear use case for transfer Sizes, maybe we just move everyone over to encoded body sizes.</span></li><li class="c0"><span class="c1">... See if people can chime in with interesting use cases</span></li><li class="c0"><span class="c2">Michal</span><span class="c1"><b></b>: I think Yoav proposed at the beginning should we remove all header sizes, or just all header sizes minus cookie sizes</span></li><li class="c0"><span class="c2">Yoav</span><span class="c1"><b></b>: Not sure if anyone is looking at them, maybe not worthwhile to preserve</span></li><li class="c0"><span class="c2">Nic</span><span>:</span><span class="c1">&nbsp;Main concern with removing header sizes out of ResourceTiming is it moves us further away from Page Weight, and when developers compare RT to Dev Tools, there would be a discrepancy.</span></li><li class="c0"><span class="c2">Benjamin</span><span class="c1"><b></b>: Question because WebKit says this is one reason they don&#39;t implement sizes, what are the other use cases?</span></li><li class="c0"><span class="c2">Yoav</span><span class="c1"><b></b>: Safari hasn&#39;t implemented encodedBodySize either, good question to ask them</span></li><li class="c0"><span class="c2">Npm</span><span class="c1"><b></b>: We already have an open problem with sizes, we want to move away from TAO with those</span></li><li class="c0"><span class="c2">Yoav</span><span class="c1"><b></b>: Can we start counting in Chrome or others, what is the weight difference between total transfer size and/or minus cookie sizes</span></li><li class="c0"><span class="c2">Nic</span><span class="c1"><b></b>: How do you actually use this, do you compare document.cookie size versus transfer sizes?</span></li><li class="c0"><span class="c2">Yoav</span><span class="c1"><b></b>: Using Fetch(), but we can clarify the attack scenario</span></li><li class="c0"><span class="c2">Michelle</span><span class="c1"><b></b>: Question around transferSize when SW is involved, we&#39;re trying to get cache hit rate when SW is involved, but it&#39;s tricky</span></li><li class="c0"><span class="c2">Yoav</span><span class="c1"><b></b>: Have ResourceTiming integrate on Response object, which already has some of those sizes. &nbsp;Integrate with Fetch and everything falls out of that.</span></li></ul></body></html>