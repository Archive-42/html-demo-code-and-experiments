<!DOCTYPE html>
<html>
<head>
  <title>Web NFC API</title>
  <meta charset="UTF-8">
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
          class='remove'>
  </script>
  <script class="remove">
    var respecConfig = {
          specStatus:           "ED",
          shortName:            "nfc",
          noLegacyStyle:        true,
          publishDate:          "",
          previousPublishDate:  "",
          previousMaturity:     "",
          edDraftURI:           "http://www.w3.org/2012/nfc/web-api/",
          // lcEnd:                "",
          crEnd:                "",
          editors: [
            { name: "Kenneth Rohde Christiansen", company: "Intel",
                    companyURL: "http://www.intel.com/" },
            { name: "Zoltan Kis", company: "Intel",
                    companyURL: "http://www.intel.com/" },
          ],
          inlineCSS:    true,
          noIDLIn:      true,
          // extraCSS:     ["../ReSpec.js/css/respec.css"],
          wg:           "NFC working group",
          wgURI:        "http://www.w3.org/2012/nfc/",
          wgPublicList: "public-nfc",
          wgPatentURI:  "http://www.w3.org/Consortium/Patent-Policy-20040205/",
          otherLinks: [
            {
              key: "Repository",
              data: [{
                    value: "We are on Github.",
                    href: "https://github.com/w3c/nfc"
                }, {
                    value: "File a bug.",
                    href: "https://github.com/w3c/nfc/issues"
                }, {
                    value: "Commit history.",
                    href: "https://github.com/w3c/nfc/commits/gh-pages"
                }
              ]
            },
          ]
    };
  </script>
</head>

<body>

<!-- - - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - - -->
<section id="abstract">
  <p>
    Near Field Communication (NFC) enables wireless communication between two
    devices at close proximity, usually less than a few centimeters.
    NFC is an international standard (ISO/IEC 18092) defining an interface and
    protocol for simple wireless interconnection of closely coupled devices
    operating at 13.56 MHz
    (see <a href="http://www.nfc-forum.org/specs/spec_list">
    http://www.nfc-forum.org/specs/spec_list</a>).
  </p>
  <p>
    This specification defines an API to manage selected NFC use-cases from Web
    applications and pages, and to enable new use-cases based on NFC technology.
  </p>
  <p>
    The generic use-cases covered in this specification are:
    <ul>
      <li>Enabling reading and writing simple consumer <a>NFC tag</a>s</li>
      <li>Allowing pushing data to another <a>NFC peer</a> device when it is
        within range.
      </li>
    </a>
  </p>
</section>

<!-- - - - - - - - - - - - Status of this document  - - - - - - - - - - - - -->
<section id="sotd">
  <p>
    Implementors need to be aware that this specification is considered unstable.
    Implementors who are not taking part in the discussions will find the
    specification changing out from under them in incompatible ways. Vendors
    interested in implementing this specification before it eventually reaches
    the Candidate Recommendation phase should subscribe to the repository on
    GitHub and take part in the discussions.
  </p>
  <p>
    Significant changes to this document since last publication are
    documented in the <a href="#Changes">Changes section</a>.
  </p>
</section>

<!-- - - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - - -->
<section id="conformance">
  <p>
    This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces
    it contains.
  </p>
  <!-- the following paragraphs are auto-generated -->
  <!--p>
    The keywords MUST, MUST NOT, REQUIRED, SHOULD, SHOULD NOT, RECOMMENDED,
    MAY, and OPTIONAL in this specification are to be interpreted as described
    in [[RFC2119]].
  </p>
  <p>
    As sections marked as non-normative, all authoring guidelines, diagrams,
    examples, and notes in this specification are non-normative. Everything else
    in this specification is normative.
  </p-->
  <p>
    Implementations that use ECMAScript to implement the APIs defined in
    this specification MUST implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]], as
    this specification uses that specification and terminology.
  </p>
</section>

<!-- - - - - - - - - - - - - - -  Terminology - - - - - - - - - - - - - - - -->
<section> <h2>Terminology</h2>
  <p>
    The
    <a href="http://dev.w3.org/html5/spec/webappapis.html#eventhandler">
    <code><dfn>EventHandler</dfn></code></a> interface represents a callback
    used for event handlers as defined in [[!HTML5]].
  </p>
  <p>
    The concepts
    <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">
      <dfn>queue a task</dfn></a> and
    <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">
    <dfn>fire a simple event</dfn></a> are defined in [[!HTML5]].
  </p>
  <p>
    The terms
    <a href="http://dev.w3.org/html5/spec/webappapis.html#event-handlers">
      <dfn>event handler</dfn></a> and
    <a href="http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">
    <dfn>event handler event types</dfn></a> are defined in [[!HTML5]].
  </p>
  <p>
    <a href='http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects'>
      <code><dfn>Promise</dfn></code></a>, and
    <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-json.parse">
      <code><dfn>JSON.parse</dfn></code></a> are defined in [[!ECMASCRIPT]].
  </p>
  <p>
    The algorithms <a href="http://www.w3.org/TR/encoding/#utf-8-encode">
    <dfn>utf-8 encode</dfn></a>, and
    <a href="http://www.w3.org/TR/encoding/#utf-8-decode">
    <dfn>utf-8 decode</dfn></a> are defined in [[!ENCODING]].
  </p>
  <p>
    <a href="http://www.w3.org/TR/dom/#eventinit">
      <dfn>EventInit</dfn></a>,
    <a href="http://www.w3.org/TR/dom/#domexception">
      <dfn>DOMException</dfn></a>,
    <a href="http://www.w3.org/TR/dom/#aborterror">
      <dfn>AbortError</dfn></a>,
    <a href="http://www.w3.org/TR/dom/#syntaxerror">
      <dfn>SyntaxError</dfn></a>,
    <a href="http://www.w3.org/TR/dom/#notsupportederror">
      <dfn>NotSupportedError</dfn></a>,
    <a href="http://www.w3.org/TR/dom/#notfounderror">
      <dfn>NotFoundError</dfn></a>, and
    <a href="http://www.w3.org/TR/dom/#securityerror">
      <dfn>SecurityError</dfn></a>
    are defined in [[!DOM4]].
  </p>
  <p>
    The term <dfn>web app</dfn> refers to a Web application, i.e. an application
    implemented using Web technologies, and executing within the context of a
    Web <a>user agent</a>, e.g. a Web browser or other Web-based runtime
    environments.
  </p>
  <p>
    The term <dfn>expressed permission</dfn> refers to an act by the user, e.g.
    via user interface or host device platform features, via which the user
    approves the permission of a <a>web app</a> to access the Web NFC API.
  </p>
  <p>
    <code><a href="http://www.w3.org/TR/FileAPI/#blob"><dfn>Blob</dfn></a>
    </code> is defined in [[!FILEAPI]].
  </p>
  <p>
    <a href="http://heycam.github.io/webidl/#idl-DOMString">
      <code><dfn>DOMString</dfn></code></a>,
    <a href="http://heycam.github.io/webidl/#idl-USVString">
      <code><dfn>USVString</dfn></code></a>,
    <a href="http://heycam.github.io/webidl/#idl-ArrayBuffer">
      <code><dfn>ArrayBuffer</dfn></code></a>,
    <a href="http://heycam.github.io/webidl/#common-BufferSource">
      <code><dfn>BufferSource</dfn></code></a> and
    <a href="http://www.w3.org/TR/WebIDL/#idl-any">
      <code><dfn>any</dfn></code></a>
    are defined in [[!WEBIDL]].
  </p>
  <p>
    <dfn>NFC</dfn> stands for Near Field Communications, short-range wireless
    technology operating at 13.56 MHz which enables communication between
    devices at a distance less than 10 cm. The NFC communications protocols and
    data exchange formats, and are based on existing radio-frequency
    identification (RFID) standards, including ISO/IEC 14443 and FeliCa.
    The NFC standards include ISO/IEC 18092[5] and those defined by the NFC
    Forum. See http://www.nfc-forum.org/specs/spec_list/ for a complete listing.
  </p>
  <p>
    An <dfn>NFC tag</dfn> is a passive, unpowered NFC device.
    The <a>NFC tag</a> is powered by magnetic induction when an active NFC
    device is in proximity range. A <a>NFC tag</a> contains a single
    <a>NDEF message</a>.
    <p class="note">
      The way of reading the message may happen through proprietary
      technologies, which require the reader and the tag to be of the same
      manufacturer. Implementations are expected to encapsulate this.
    </p>
  </p>
  <p>
    An <dfn>NFC peer</dfn> is another device, which can interact with other
    devices in order to exchange data using NFC.
  </p>
  <p>
    An <dfn>NDEF message</dfn> encapsulates one or more application-defined
    <a>NDEF record</a>s. <dfn>NDEF</dfn> stands for NFC Forum Data Exchange
    Format, a lightweight binary message format. NDEF messages can be stored on
    a <a>NFC tag</a> or exchanged between NFC-enabled devices.
  </p>
  <p>
    An <dfn>NDEF record</dfn> has a maximum payload of 2^32-1 bytes. The record
    also contains information about the payload size, type, and an optional
    identifier. NFC Forum standardized a small set of useful data types to be
    used in <a>NDEF record</a>s, for instance text, URL, media. In addition,
    there are record types designed for more complex interactions, such as
    Smart Poster, and handover records.
  </p>
  <p>
    Part of the <a>NDEF record</a> is the <dfn>TNF</dfn> field, standing for
    Type Name Format. It can take binary values representing the following
    types:
    <table class="simple" border="1">
      <tr>
        <th><strong>TNF value</strong></th>
        <th><strong>NDEF record type</strong></th>
      </tr>
      <tr>
        <td>0</td>
        <td><dfn>Empty</dfn></td>
      </tr>
      <tr>
        <td>1</td>
        <td>NFC Forum <dfn>Well-Known Type</dfn>
        </td>
      </tr>
      <tr>
        <td>2</td>
        <td><dfn>Media Type</dfn></td>
      </tr>
      <tr>
        <td>3</td>
        <td><dfn>Absolute URI</dfn></td>
      </tr>
      <tr>
        <td>4</td>
        <td>NFC Forum <dfn>External Type</dfn></td>
      </tr>
      <tr>
        <td>5</td>
        <td><dfn>Unknown</dfn></td>
      </tr>
      <tr>
        <td>6</td>
        <td><dfn>Unchanged</dfn></td>
      </tr>
      <tr>
        <td>7</td>
        <td><dfn>Reserved</dfn></td>
      </tr>
    </table>
    NFC Forum <a>Well-Known Type</a> includes record types <i>text</i>,
    <i>URI</i>, <i>Smart Poster</i> (containing a URI or other
    data and possible actions).
  </p>
  <p>An <dfn>NFC handover</dfn> defines NFC Forum Well Known Types and the
    corresponding message structure that allows negotiation and activation of
    an alternative communication carrier, such as Bluetooth or WiFi.
    The negotiated communication carrier would then be used (separately) to
    perform certain activities between the two devices, such as sending photos
    to the other device, printing to a Bluetooth printer or streaming video to
    a television set.
  </p>
  <p>
    The term <dfn>sufficient permission</dfn> in this document means that a
    <a>web app</a> which is invoking the methods of this API has been checked to
    comply with the security policies set by the underlying platform and API
    implementation in the moment and context of invoking the API method.
  </p>
  <p>
    The term
    <a href="http://www.w3.org/TR/2011/WD-html5-20110113/urls.html#document-base-url">
    <dfn>document base URL</dfn></a> is defined in [[!HTML5]].
  </p>
  <p>
    The term <dfn>URL scope</dfn> is introduced in this document for NFC
    operations as a sub-string match to the <a>web app</a>'s
    document URL, which includes the domain of the calling <a>web app</a>.
    The URL scope is stored in the <var>identifier</var> field of an
    <a>NDEF record</a>.
  </p>
</section> <!-- Terminology -->

<!-- - - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Introduction</h2>
  <p>
    There are three groups of application scenarios for NFC:
    <ul>
      <li>
        Hold a device close to a passive wireless tag (which could be in the
        form of a plastic card) to read and write or overwrite data (in the
        case the tag is not read-only).
      </li>
      <li>
        Hold two powered devices, e.g. phones or tablets, close to each other
        in order to push data from one to the other, or to initiate a connection
        using another wireless carrier such as Bluetooth or WiFi.
      </li>
      <li>Card emulation
       <ol>
        <li>
          With a secure element: for payments by holding your phone close to a
          point-of-sales terminal, instead of swiping a payment card.
        </li>
        <li>With host card emulation: for allowing use-cases like using a phone
          as a hotel room key card.
        </li>
       </ol>
      </li>
    </ul>
  </p>
  <p>
    NFC works using magnetic induction, meaning that the reader will emit a
    small electric charge which then creates a magnetic field. This field powers
    the passive device which turns it in to electrical impulses to communicate
    data. Thus, when the devices are within range, a read is always performed
    (see NFC Analog Specification and NFC Digital Protocol, NFC Forum, 2006).
    The peer-to-peer connection works in a similar way, as the device
    periodically switches into a so-called initiator mode in order to scan for
    targets, for then to fall back into target mode. If a target is found, the
    data is read the same way as for tags.
  </p>
  <p>
    As <a>NFC</a> is based on existing RFID standards, many NFC chipsets support
    reading legacy RFIDs tags, but many of these are only supported by single
    vendors and not part of the NFC standards. Though certain devices support
    reading and writing to these, it is not a goal of this specification to
    support proprietary tags or support interoperability with legacy systems.
  </p>
  <p>
    The NFC Forum has mandated the support of four different tag types to be
    operable with NFC devices. The same is required on operating systems such as
    Android.
    <ol>
      <li>
        <b>NFC Forum Type 1</b>: This tag is based on the ISO/IEC 14443-3A
        (also known as NFC-A,  as defined in ISO/IEC 14443-3:2011, Part 3:
        Initialization and anticollision). The tags are rewritable and can be
        configured to become read-only. Memory size can be between 96 bytes and
        2 Kbytes. Communication speed is 106 kbit/sec.
      </li>
      <li><b>NFC Forum Type 2</b>: This tag is also based on the
        ISO/IEC 14443-3A (NFC-A). The tags are rewritable and can be configured
        to become read-only. Memory size can be between 48 bytes and 2 Kbytes.
        Communication speed is 106 kbit/sec. In contrast to Type 1, Type 2 has
        anti-collision protection for dealing with multiple tags within the NFC
        field.
      </li>
      <li><b>NFC Forum Type 3</b>: This tag is based on the Japanese Industrial
        Standard (JIS) X 6319-4, commonly known as FeliCa. The tags are
        preconfigured to be either rewritable or read-only. Memory availability
        is variable, theoretical memory limit is 1MByte per service.
        Communication speed is 106 kbit/sec.  Like Type 2, it supports
        anti-collision protection.
      </li>
      <li><b>NFC Forum Type 4</b> (November 2010): This tag is based on the
        ISO/IEC 14443 like Type 1 and 2, but it support either NFC-A or NFC-B
        for communication. On top of that the tag may support the Data Exchange
        Protocol (aka ISO-DEP) defined in ISO/IEC 14443 (ISO/IEC 14443-4:2008
        Part 4: Transmission protocol). Like Type 3, the tags are preconfigured
        to be either rewritable or read-only. Variable memory, up to 32 KB per
        service. Supports three different communication speeds 106 or 212 or
        424 Kbits/s.
      </li>
    </ol>
  </p>
  <p>
    In addition to data types standardized for <a>NDEF record</a>s by the NFC
    Forum, many commercial products, e.g. bus cards, door openers etc, use
    different card specific data and protocol extensions which require specific
    NFC chips (same vendor of card and reader) in order to work.
  </p>
  <p>
    Card emulation mode capabilities also depend on the NFC chip in the device.
    For payments, a Secure Element is often needed.
  </p>
  <section> <h3>Use Cases</h3>
    <p>High level use cases for the Web NFC specification include the following:
      <ol>
        <li>Support devices with single or multiple NFC adapters.</li>
        <li>Support communication with active (powered devices such as readers,
          phones) and passive (smart cards, tags, etc) devices.</li>
        <li>Allow users to act on (e.g. read, write or transceive) discovered
          NFC devices (passive and active) as well as access the NDEF records
          which were read in the process.</li>
        <li>Allow the user to write a payload via NDEF records to compatible
          devices, such as writeable tags, when they come in range.</li>
        <li>Allow manual connection for various technologies such as NFC-A and
          NFC-F depending on secondary device.</li>
        <li>Allow <a>NFC handover</a> to Bluetooth or WiFi.</li>
        <li>Allow card emulation with secure element or host card emulation.
        </li>
      </ol>
    </p>
    <p class="note">Note that the last 3 use cases are not supported in this
      version of the specification.
    </p>
    <p>
      NFC is usually deeply integrated into device platforms (e.g. Android,
      Windows, etc), because end-to-end user experience implications (e.g.
      users need to be presented platform specific dialogs for selecting
      applications and actions). Also, privacy and security related issues
      require platform specific solutions.
    </p>
    <p>
      The various integrated technologies, wide variety of use cases, and platform
      integration issues make standardization of NFC for the web a challenge.
      Therefore this specification makes a few simplifications in what use cases
      and data types are possible to handle by users of this API:
      <ul>
        <li>Expose data types already known to web browsers as MIME types.</li>
        <li>Use the web security model.</li>
        <li>Implementations encapsulate <a>NDEF record</a> handling and the API
          exposes only data and control events.
        </li>
      </ul>
    </p>
    <p class="note">
      Handover scenarios are expected to be completely encapsulated by
      implementations. A later version of this API may expose initiating a
      handover over Bluetooth or WiFi, but in either case implementations and
      underlying platforms are assumed to handle handover records according to
      their capabilities.
      </p>
    <p class="note">
      Implementations MAY handle Smart Poster
      (see "Smart Poster RTD Specification", NFC Forum, 2006) record types,
      and may expose their data to <a>web app</a>s through this API.
    </p>
  </section> <!-- Use Cases -->
  <section> <h3>Technical requirements</h3>
    <p>The following high level technical requirements result from the
      enumerated use cases:
      <ol>
        <li>Enumerate NFC adapters.</li>
        <li>Set up watchers to read for a given scope (a default scope being
          set by implementations to the origin of the page).</li>
        <li>Provide event for read completed as NDEF records from tag or peer
          device. Expose payload as MIME type. Eventually expose binary content
          of NDEF records.</li>
        <li>Set a predefined payload, or full binary NDEF records that the user
          can push to another device when within range. Provide event for
          completed push.
        </li>
        <li>Manage manual connections for various NFC technologies. Provide
          proximity events when tags and peers appear and disappears</li>
        <li>Set up the card content to be read by other devices for Host Card
          Emulation.</li>
        <li>Configure a predefined handover to Bluetooth or WiFi.</li>
      </ol>
    </p>
    <p class="note">Note that the last 3 technical requirements are not
      supported in this version of the specification.
    </p>
  </section> <!-- Technical requirements -->
</section> <!-- Introduction -->


<!-- - - - - - - - - - - - - - - Usage Examples - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Usage Examples</h2>
  <p>
    This section shows how developers can make use of the various features of
    this specification.
  </p>
  <pre title="Read and write data from tag" class="example highlight">
    navigator.nfc.requestTagRegistration({ scope: "/jumpyjack" }).then(
      (registration) => {
        // Listen for any incoming messages (tag reads).
        registration.onmessage = (ev) => {
          if (ev.message.length > 0)
            console.log("Current stored progress: " + ev.message[0].progress);
          // Write new progress (level 42) to tag.
          registration.write({ progress: 42 }, "/jumpyjack");
        };
      },
      (error) => {
        console.log("Oops something went wrong: " + error);
      }
    });
  </pre>
</section> <!-- Usage examples -->


<!-- - - - - - - - - - - - - Security and Privacy - - - - - - - - - - - - - -->
<section> <h2>Security and Privacy Considerations</h2>
  <p>
    <a title="user agent">User agents</a> MUST NOT provide Web NFC API access
    to <a>web app</a>s without the
    <a>expressed permission</a> of the user. User agents must acquire consent
    for permission through a user interface for each call to the request*()
    methods, unless a prearranged trust relationship applies.
  </p>
  <p>
    User agents may support prearranged trust relationships that do not require
    such per-request user interfaces.
  </p>
  <p class="note">
    Considering adding the following:
    User agents MUST implement the WebNFC API to be HTTPS-only. SSL-only support
    provides better protection for the user against man-in-the-middle attacks
    intended to obtain push registration data. Browsers may ignore this rule
    for development purposes only.
  </p>
  <p>
    Permissions that are preserved beyond the current browsing session must be
    revocable.
  </p>
</section> <!-- Security and Privacy  -->


<!-- - - - - - - - - - - - - Data types and content - - - - - - - - - - - - -->
<section> <h2>Data types and content</h2>
  <!-- NfcMessageType -->
  <section><h3>Data types</h3>
    <p>
      This API exposes the following data types originating from
      <a>NDEF message</a>s.
    </p>
    <dl
      title="typedef NfcMessageType = DOMString | URL | Blob | JSON"
      class="idl">
    </dl>
    <p>
      The mapping from <a>NDEF record</a> types to supported
      <code><dfn>NfcMessageType</dfn></code> is as follows:
    </p>
    <table class="simple" border="1">
      <tr>
        <th>NfcMessageType</th>
        <th>NDEF record type</th>
      </tr>
      <tr>
        <td><strong>DOMString</strong></td>
        <td>NFC Forum Well Known Type (<a>TNF</a>=1) with type <i>Text</i></td>
      </tr>
      <tr>
        <td><strong>URL</strong></td>
        <td><ul>
          <li>NFC Forum Well Known Type (<a>TNF</a>=1) with type <i>URI</i></li>
          <li>NFC Forum Well Known Type (<a>TNF</a>=1) with type
            <i>Smart Poster</i>
          </li>
          <li>Absolute URI as defined in RFC 3986 (<a>TNF</a>=3)</li>
        </ul></td>
      </tr>
      <tr>
        <td><strong>JSON</strong></td>
        <td>Media-type as defined in RFC 2046 (<a>TNF</a>=2) with associated
          <i>MIME type</i> <code>"application/webnfc+json"</code>
        </td>
      </tr>
      <tr>
        <td><strong>Blob</strong></td>
        <td>
          <ul>
            <li>Media-type as defined in RFC 2046 (<a>TNF</a>=2)</li>
            <li>NFC Forum External Type (<a>TNF</a>=4)</li>
            <li>Unknown (<a>TNF</a>=5)</li>
            <li>Any <a>NDEF record</a> type that is not covered by DOMString,
              URL and JSON types.
            </li>
          </ul>
        </td>
      </tr>
    </table>
    </section> <!-- data types -->

  <!-- NfcMessageData -->
  <section><h3>The <strong>NfcMessageData</strong> interface</h3>
    <p>
      The content of the <a>NDEF message</a> is exposed by the following
      interface:
    </p>
    <dl title="interface NfcMessageData" class="idl">
      <dt>readonly attribute DOMString contentType</dt>
      <dt>USVString url ()</dt>
      <dt>ArrayBuffer arrayBuffer ()</dt>
      <dt>Blob blob ()</dt>
      <dt>any json ()</dt>
      <dt>DOMString text ()</dt>
    </dl>
    <p>
      <a>NfcMessageData</a> objects have associated data read by the NFC chip
      upon creation.
    </p>
    <p>
      The <code>
      <dfn id="widl-NfcMessageData-contentType">contentType</code>
      attribute describes the type of data such as MIME type and additional
      information for text messages, e.g.
      <code>"text/plain;charset=UTF-8;"</code>
    </p>
    <p>
      The <code><dfn id="widl-NfcMessageData-url-USVString">url()</dfn></code>
      method, when invoked, MUST return a <a><code>USVString</code></a>
      representing any URL stored in the <a>NDEF message</a> or
      <code>undefined</code>.
    </p>
    <p>
      The <code><dfn id="widl-NfcMessageData-arrayBuffer-ArrayBuffer">
      arrayBuffer()</dfn></code> method, when invoked, MUST return an
      <a><code>ArrayBuffer</code></a> whose contents are <var>bytes</var>.
    </p>
    <p>
      The <code><dfn id="widl-NfcMessageData-blob-Blob">blob()</dfn></code>
      method, when invoked, MUST return a <a><code>Blob</code></a> whose
      contents are <var>bytes</var>.
    </p>
    <p>
      The <code><dfn id="widl-NfcMessageData-json-any">json()</dfn></code>
      method, when invoked, MUST return the result of invoking the initial
      value of <a><code>JSON.parse</code></a> with the result of running
      <a>utf-8 decode</a> on <var>bytes</var> as argument.
      Re-throw any exceptions thrown by <a><code>JSON.parse</code></a>.
    </p>
    <p>
      The <code><dfn id="widl-PushMessageData-text-DOMString">text()</dfn>
      </code> method, when invoked, MUST return the result of running
      <a>utf-8 decode</a> on<var>bytes</var>.
    </p>
  </section> <!-- NfcMessageData interface -->

  <!-- NfcMessageEvent -->
  <section> <h3>The <strong>NfcMessageEvent</strong> interface</h3>
  <p>
    In this specification, <a>NDEF message</a> content is delivered by an
    <a>NfcMessageEvent</a> event.
  </p>
  <dl title="interface NfcMessageEvent : Event" class="idl">
    <dt>readonly attribute USVString scope</dt>
    <dt>readonly attribute NfcMessageData[] message</dt>
  </dl>
  <p>
    The <code><dfn id="widl-NfcMessageEvent-scope">scope</dfn></code> property
    represents the <a>URL scope</a> of the <a>NDEF message</a>.
  </p>
  <p>
    The <code><dfn id="widl-NfcMessageEvent-message">message</dfn></code>
    property represents the <code><a>NfcMessageData</a></code> content of the
    <a>NDEF message</a>.
  </p>
  </section> <!-- NfcMessageEvent -->
</section> <!-- Data types and content -->


<!-- - - - - - - - - - - Extended interface Navigator - - - - - - - - - - - -->
<section> <h2>Extensions to the <strong>Navigator</strong> interface</h2>
  <p>
    The HTML specification defines a
    <a href="http://www.whatwg.org/specs/web-apps/current-work/#dom-navigator">
    <code>Navigator</code></a> interface [HTML] which this specification
    extends.
  </p>
  <dl title="partial interface Navigator" class="idl">
    <dt>readonly attribute NFC nfc</dt>
  </dl>
  <!-- - - - - - - - - - - - nfc attribute  - - - - - - - - - - - -->
  <section> <h3>The <strong>nfc</strong> attribute</h3>
  <p>
    When getting the <dfn id="widl-Navigator-nfc">nfc</dfn> attribute, the
    <a>user agent</a> MUST return the <a>NFC</a> object, which provides
    NFC related functionality.
  </p>
  </section> <!-- nfc attribute -->
</section> <!-- Navigator -->

<section> <h2>The <strong>NFC</strong> interface</h2>
  <dl title="interface NFC" class="idl">
    <dt>Promise&lt;NfcTagRegistration&gt;
        requestTagRegistration(RegistrationOptions? options)</dt>
    <dt>Promise&lt;NfcPeerRegistration&gt;
        requestPeerRegistration(RegistrationOptions? options)</dt>
  </dl>
  <p>
    By using these methods, <a>web app</a>s can obtain
    control objects providing NFC functionality, separately for handling passive
    <a>NFC tag</a>s and communication with active <a>NFC peer</a>s,
    in a similar way to that of service worker extensions [[SERVICE-WORKERS]].
  </p>
  <p>
    As <a>web app</a>s might not be interested in all peer and tag messages,
    the messages have an associated identifier represented as a
    <a>URL scope</a>, which enables filtering based on this scope, and also
    based on content types the <a>web app</a> can or wants to handle.
  </p>
  <p>
    When writing or pushing messages to peers, the <a>document base URL</a>
    serves as the default scope, though another <a>URL scope</a> can be set with
    the restriction that it MUST include the document domain (e.g.
    http://www.w3.org for any data exchange from http://www.w3.org/TR/nfc/).
  </p>
  <p>
    Using a different scope can be useful in order to easily differentiate
    messages and use different registrations and event handlers per scope.
  </p>
  <p>
    To describe which messages a registration should apply to, the following
    dictionary is used:
  </p>
  <section> <h3>The <strong>RegistrationOptions</strong> dictionary</h3>
    <dl title="dictionary RegistrationOptions" class="idl">
      <dt>USVString? scope</dt>
      <dt>DOMString[] contentTypes</dt>
    </dl>
    <p>
      The <dfn id="widl-RegistrationOptions-scope">scope</dfn> property
      denotes the <a>URL scope</a> for which all messages MUST belong to for the
      given registration.
      If the value is <code>null</code> or <code>undefined</code>,
      then implementations SHOULD use the <a>web app</a>'s
      <a>document base URL</a>.
    </p>
    <p>
      The
      <dfn id="widl-RegistrationOptions-contentTypes">contentTypes</dfn>
      property denotes the list of MIME types, that the registrations wants to
      handle.
    </p>
    <pre
      title="Filter accepting only JSON based messages from http://www.w3.org"
      class="example highlight">
    var registrationOptions = {
      scope: "http://www.w3.org",
      contentTypes: ["application/manifest+json", "application/json", "text/json"]
    }
    </pre>
    <pre
      title="Filter which only accept JSON based messages from https://01.org/registration for authentication"
      class="example highlight">
    var registrationOptions = {
      scope: "https://01.org/registration",
      contentTypes: ["application/json"]
    }
    </pre>
  </section> <!-- RegistrationOptions -->

  <!-- within-scope algorithm -->
  <section> <h3>The <strong><dfn>within-scope</dfn></strong> algorithm</h3>
    <p>
      <strong>Preconditions</strong>: a registration object (either
      <code><a>NfcTagRegistration</a></code> or
      <code><a>NfcPeerRegistration</a></code>) exists with an associated
      object of type <code><a>RegistrationOptions</a></code>,
      which contains <code>registeredScope</code> <a>URL scope</a>.
    </p>
    <p>
      <strong>Input</strong>: <var>url</var>, a URL to be checked for being
      <a>within-scope</a>.
    </p>
    <p><strong>Output</strong>: <code>true</code> or <code>false</code></p>
    <p>
      When filtering <a>NDEF message</a>s associated with <var>url</var>, based
      on <a>URL scope</a>, run the following steps atomically.
      <ol>
        <li>
          If <var>registeredScope</var> is <code>undefined</code>, then let
          <var>scope</var> be the calling <a>web app</a>'s <a>document base
          URL</a>, otherwise let <var>scope</var> be <var>registeredScope</var>.
        </li>
        <li>
          If <var>url</var> is same origin as <var>scope</var> and
          <var>url</var>'s <code>pathname</code> starts with <var>scope</var>s
          <code>pathname</code>, return <code>true</code>,
          otherwise return <code>false</code>.
        </li>
      </ol>
    </p>
  </section> <!-- within-scope algorithm -->

  <!-- requestTagRegistration() method -->
  <section> <h3>The <strong>requestTagRegistration()</strong> method</h3>
  <p>
    The <code>
    <dfn id="widl-Navigator-requestTagRegistration-Promise-FilterOptions-filter">
    requestTagRegistration</dfn>()</code> method provides a control object for
    handling NFC functionality related to <a>NFC tag</a>s. When this method is
    invoked, the <a>user agent</a> MUST run the following steps:
    <ol id="steps-requestTagRegistration">
      <li>Let <var>promise</var> be a new <a><code>Promise</code></a> object.
      </li>
      <li>
        Return <var>promise</var> and continue the following steps
        asynchronously.
      </li>
      <li>
        If there are no <a>sufficient permission</a>s to use this method,
        then reject <var>promise</var> with a new
        <code><a>DOMException</a></code> object whose <var>name</var> property
        is set to <code>"<a>SecurityError</a>"</code>, and terminate these steps.
      </li>
      <li>
        If there is no support for <a>NFC tag</a> handling functionality in
        hardware, software, or due to physical incompatibility,
        then reject <var>promise</var> with a new
        <code><a>DOMException</a></code> object whose <var>name</var> property
        is set to <code>"<a>NotSupportedError</a>"</code>, and terminate
        these steps.
      </li>
      <li>
        Parse the argument <var>filter</var>. If it is invalid in the given
        platform, then reject <var>promise</var> with a new
        <code><a>DOMException</a></code> object whose <var>name</var> property
        is set to <code>"<a>SyntaxError</a>"</code>, and terminate these steps.
      </li>
      <li>
        Make a request to the underlying platform to initialize NFC
        functionality. If the request fails, then reject <var>promise</var>
        with a new <code><a>DOMException</a></code> object whose <var>name</var>
        property is set to <code>"<a>NotSupportedError</a>"</code>,
        and terminate these steps.
      </li>
      <li>
        If the request is successful, then resolve <var>promise</var> with a
        <code><a>NfcTagRegistration</a></code> object with filtering for
        incoming data types described by the <var>filter</var> parameter, i.e.
        fire <code>message</code> events only for messages <a>within-scope</a>
        and accepted content types.
      </li>
      <li>
        Whenever the <a>user agent</a> detects an <a>NFC tag</a> which matches
        the filter associated with an <code><a>NfcTagRegistration</a></code>
        object, <a>queue a task</a> to fire a <code>"message"</code> event at
        the object.
      </li>
    </ol>
  </p>
  </section>  <!-- requestTagRegistration() method -->

  <!-- requestPeerRegistration() method -->
  <section> <h3>The <strong>requestPeerRegistration()</strong> method</h3>
  <p>
    The <code>
    <dfn id="widl-Navigator-requestPeerRegistration-Promise-FilterOptions-filter">
    requestPeerRegistration</dfn>()</code> method provides a control object for
    handling NFC functionality related to <a>NFC peer</a>s. When this method is
    invoked, the <a>user agent</a> MUST run the following steps:
    <ol id="steps-requestPeerRegistration">
      <li>Let <var>promise</var> be a new <a><code>Promise</code></a> object.
      </li>
      <li>
        Return <var>promise</var> and continue the following steps
        asynchronously.
      </li>
      <li>
        If there are no sufficient permissions to use this method,
        then reject <var>promise</var> with a new
        <code><a>DOMException</a></code> object whose <var>name</var> property
        is set to <code>"<a>SecurityError</a>"</code>,
        and terminate these steps.
      </li>
      <li>
        If there is no support for <a>NFC tag</a> handling functionality in the
        device, then reject <var>promise</var> with a new
        <code><a>DOMException</a></code> object whose <var>name</var> property
        is set to <code>"<a>NotSupportedError</a>"</code> , and
        terminate these steps.
      </li>
      <li>
        Parse the argument <var>filter</var>. If it is invalid in the given
        platform, then reject <var>promise</var> with a new
        <code><a>DOMException</a></code> object whose <var>name</var> property
        is set to <code>"<a>SyntaxError</a>"</code>, and terminate these steps.
      </li>
      <li>
        Make a request to the underlying platform to initialize NFC
        functionality.
        If the request fails, then reject <var>promise</var> with a new
        <code><a>DOMException</a></code> object whose <var>name</var> property
        is set to <code>"NotSupportedError"</code> , and terminate these steps.
      </li>
      <li>
        If the request is successful, then resolve <var>promise</var> with a
        <code><a>NfcPeerRegistration</a></code> object with filtering for
        incoming data types described by the <var>filter</var> parameter, i.e.
        fire <code>message</code> events only for messages <a>within-scope</a>
        and accepted content types.
      </li>
      <li>
        Whenever the <a>user agent</a> detects an <a>NFC tag</a> which matches
        to the filter associated with a <code><a>NfcTagRegistration</a></code>
        object, <a>queue a task</a> to fire an <code>"message"</code> event at
        the object.
      </li>
    </ol>
  </p>
  </section> <!-- requestPeerRegistration() method -->
</section> <!-- Navigator -->

<!-- - - - - - - - - - - NfcTagRegistration interface - - - - - - - - - - - -->
<section> <h2>The <strong>NfcTagRegistration</strong> interface</h2>
  <dl title="interface NfcTagRegistration : EventHandler"
      class="idl">
    <dt>Promise write(NfcMessageType message, USVString scope)</dt>
    <dt>attribute EventHandler onmessage</dt>
  </dl>
  <p>
    The following are the event handlers implemented by the
    <code><a>NfcTagRegistration</a></code> interface.
  </p>
  <table class="simple">
    <tr>
      <th>event handler</th>
      <th>event name   </th>
      <th>event type   </th>
    </tr>
    <tr>
      <td>
        <code><dfn id="widl-NfcTagRegistration-onmessage">onmessage</dfn></code>
      </td>
      <td><code>message</code></td>
      <td><code><a>NfcMessageEvent</a></code></td>
    </tr>
  </table>

  <section> <h3>The <strong>message</strong> event</h3>
  <p>
    The <code>message</code> event is used for notifying the registration
    objects about messages dispatched to the <a>web app</a> via NFC.
  </p>
  </section>

  <!-- The write() method -->
  <section><h3>The <strong>write</strong>() method</h3>
    <p>
      The <code>
      <dfn id="widl-NfcTagRegistration-write-Promise-NfcMessageType-message-USVString-scope">
      write</dfn>()</code> method is used for writing an <a>NFC tag</a>, if
      possible. When this method is invoked, the <a>user agent</a> MUST run the
      following steps:
    <ol id="steps-NfcTagRegistration-write">
      <li>
        Let <var>promise</var> be a new <a><code>Promise</code></a> object.
      </li>
      <li>
        Return <var>promise</var> and continue the following steps
        asynchronously.
      </li>
      <li>
        If there are no sufficient permissions to use this method, then reject
        <var>promise</var> with a new <code><a>DOMException</a></code> object
        whose <var>name</var> property is set to
        <code>"<a>SecurityError</a>"</code>, and terminate these steps.
      </li>
      <li>
        If there is no support for the functionality of writing an
        <a>NFC tag</a> in proximity range, then reject <var>promise</var> with
        a new <code><a>DOMException </a></code> object whose <var>name</var>
        property is set to <code>"<a>NotSupportedError</a>"</code>, and
        terminate these steps.
      </li>
      <li>
        Parse the argument <var>message</var>. If it is invalid on the given
        platform, then reject <var>promise</var> with a new
        <code><a>DOMException</a></code>
        object whose <var>name</var> property is set to
        <code>"<a>SyntaxError</a>"</code>, and terminate these steps.
        If valid, create an appropriate <a>NDEF message</a>, i.e. a list of
        <a>NDEF record</a>s to be written to the <a>NFC tag</a>, denoted by
        <var>output</var>.
      </li>
      <li>
        Parse the argument <var>scope</var>. If it is invalid in the given
        platform, then reject <var>promise</var> with a new
        <code><a>DOMException</a></code>
        object whose <var>name</var> property is set
        to <code>"<a>SyntaxError</a>"</code>, and terminate these steps.
        If the value is <code>undefined</code>, then attribute to
        <var>scope</var> the <code>USVString</code> describing the
        <a>document base URL</a>.
      </li>
      <li>
        Make a request to the underlying platform to write <var>output</var>
        to the <a>NFC tag</a> in proximity range. If the request fails, then
        reject <var>promise</var> with a new <code><a>DOMException</a></code>
        object whose <var>name</var> property is set to
        <code>"NotSupportedError"</code>, and terminate these steps.
      </li>
      <li>
        If the request is successful, then resolve <var>promise</var>.
      </li>
    </ol>
  </section> <!-- write() method -->
</section> <!-- NfcTagRegistration interface -->

<!-- - - - - - - - - - - NfcPeerRegistration interface  - - - - - - - - - - -->
<section> <h2>The <strong>NfcPeerRegistration</strong> interface</h2>
  <dl title="interface NfcPeerRegistration : EventHandler"
      class="idl">
    <dt>Promise setPushMessage(NfcMessageType message, USVString scope)</dt>
    <dt>attribute EventHandler onmessagepushed</dt>
    <dt>attribute EventHandler onmessage</dt>
  </dl>
  <!-- Events -->
  <p>
    The following are the event handlers implemented by the
    <code><a>NfcTagRegistration</a></code> interface.
  </p>
  <table class="simple">
    <tr>
      <th>event handler</th>
      <th>event name   </th>
      <th>event type   </th>
    </tr>
    <tr>
      <td>
        <code><dfn id="widl-NfcPeerRegistration-onmessage">onmessage</dfn></code>
      </td>
      <td><code>message</code></td>
      <td><code><a>NfcMessageEvent</a></code></td>
    </tr>
    <tr>
      <td>
        <code>
        <dfn id="widl-NfcPeerRegistration-onmessagepushed">onmessagepushed</dfn>
        </code>
      </td>
      <td><code>messagepushed</code></td>
      <td><code><a>NfcMessageEvent</a></code></td>
    </tr>
  </table>
  <section><h3>the <strong>message</strong> event</h3>
    <p>
      The <code>message</code> event is used for notifying the registration
      objects about messages dispatched to the <a>web app</a> via NFC.
    </p>
  </section> <!-- the message event -->
  <section><h3>the <strong>messagepushed</strong> event</h3>
    <p>
      As messages are not automatically pushed to peers when they detect each
      other, but most often requires some kind of user interaction, a
      <code>messagepushed</code> event exists which will be called when a
      message has been successfully pushed to the other peer.
    </p>
  </section> <!-- the messagepushed event -->

  <section><h3>The <strong>setPushMessage()</strong> method</h3>
    <p>
      The <code>
      <dfn id="widl-NfcPeerRegistration-setPushMessage-NfcMessageType-message-USVString-scope">
      setPushMessage</dfn>()</code> method is used for setting the messages
      which the user can push to another peer when it gets into proximity range.
      When this method is invoked, the <a>user agent</a> MUST run the following
      steps:
      <ol id="steps-NfcTagRegistration-setPushMessage">
        <li>
          Let <var>promise</var> be a new <a><code>Promise</code></a> object.
        </li>
        <li>
          Return <var>promise</var> and continue the following steps
          asynchronously.
        </li>
        <li>
          If there are no sufficient permissions to use this method, then reject
          <var>promise</var> with a new <code><a>DOMException</a></code> object
          whose <var>name</var> property is set to
          <code>"<a>SecurityError</a>"</code>, and terminate these steps.
        </li>
        <li>
          If there is no support for the functionality of sending data to an
          <a>NFC peer</a> in proximity range, then reject <var>promise</var>
          with a new <code><a>DOMException </a></code> object whose
          <var>name</var> property is set to
          <code>"<a>NotSupportedError</a>"</code>, and terminate these steps.
        </li>
        <li>
          Parse the argument <var>message</var>. If it is invalid on the given
          platform, then reject <var>promise</var> with a new
          <code><a>DOMException</a></code>
          object whose <var>name</var> property is set to
          <code>"<a>SyntaxError</a>"</code>, and terminate these steps.
          If valid, create an appropriate <a>NDEF message</a>, i.e. a list of
          <a>NDEF record</a>s to be written to the <a>NFC tag</a>, denoted by
          <var>output</var>.
        </li>
        <li>
          Parse the <var>message</var> parameter. If it is invalid or
          incompatible in the given platform, then reject <var>promise</var>
          with a new <code><a>DOMException</a></code> object whose
          <var>name</var> property is set to <code>"<a>SyntaxError</a>"</code>,
          and terminate these steps.
        </li>
        <li>
          Let <var>output</var> be a newly composed <a>NDEF message</a> which
          matches best the content of <var>message</var>.
          Set the <code>id</code> field of the <a>NDEF record</a>s to
          <var>scope</var>.
        </li>
        <li>
          Make a request to the underlying platform to write <var>output</var>
          to <a>NFC peer</a>s in proximity range. If the request fails, then
          reject <var>promise</var> with a new <code><a>DOMException</a></code>
          object whose <var>name</var> property is set to
          <code>"NotSupportedError"</code>, and terminate these steps.
        </li>
        <li>
          If the request is successful, then resolve <var>promise</var>.
        </li>
      </ol>
    </p>
  </section> <!-- setPushMessage() method -->
</section> <!-- NfcPeerRegistration interface -->


<!-- - - - - - - - - - - - - - -  Changes - - - - - - - - - - - - - - - - - -->
<section class="appendix" id="Changes"><h2>Changes</h2>
  <p>
    The following is a list of substantial changes to the document. For a
    complete list of changes, see the <a href=
    "https://github.com/w3c/nfc/commits/gh-pages">change log on
    Github</a>. You can also view the <a href=
    "https://github.com/w3c/nfc/issues?page=1&amp;state=closed">
    recently closed bugs</a>.
  </p>
  <ul>
    <li>Redesigned the API to follow contemporary web design patterns</li>
    <li>Change of editors</li>
  </ul>
</section>


<!-- - - - - - - - - - - - - - - Acknowledgements - - - - - - - - - - - - - -->
<section> <h2>Acknowledgements</h2>
  <p>
    The editors would like to express their gratitude to the former editors
    Luc Yriarte and Samuel Ortiz, and also to Don Coleman, Marcos Caceres and
    Salvatore Iovene for their technical guidance, implementation feedback and
    support.
  </p>
</section>

</body>
</html>
