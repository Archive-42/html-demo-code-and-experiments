<html>
<head>
<title>System Dependencies in the W3 Library</title>
</head>
<body>
<h1>System Dependencies</h1>
<p>This file contains most of the system-dependent code in the W3 Library.
It begins with the <tt>config.h</tt> file (usually) generated by the automatic
configuration, and leverages out from there.</p>

<h2>Authors</h2>
<dl>
    <dt>TBL
    <dd>Tim Berners-Lee, W3 project, CERN, &lt;timbl@info.cern.ch&gt;

    <dt>EvA
    <dd>Eelco van Asperen &lt;evas@cs.few.eur.nl&gt;

    <dt>MA
    <dd>Marc Andreesen NCSA

    <dt>MD
    <dd>Mark Donszelmann &lt;duns@vxcern.cern.ch&gt;

    <dt>AT
    <dd>Aleksandar Totic &lt;atotic@ncsa.uiuc.edu&gt;

    <dt>SCW
    <dd>Susan C. Weber &lt;sweber@kyle.eitech.com&gt;

    <dt>HF
    <dd>Henrik Frystyk, &lt;frystyk@dxcern.cern.ch&gt;

    <dt>fgmr
    <dd><a href="http://info.cern.ch/roeber/fgmr.html">Frederick G.M. Roeber</a> &lt;roeber@cern.ch&gt;
</dl>

<h2>History</h2>
<dl>
    <dt>22 Feb 91
    <dd>Written (TBL) as part of the WWW Library.

    <dt>16 Jan 92
    <dd>PC code from EvA

    <dt>22 Apr 93
    <dd>Merged diffs bits from xmosaic release

    <dt>29 Apr 93
    <dd>Windows/NT code from SCW

    <dt>29 Sep 93
    <dd>VMS fixes (MD)

    <dt>15 Nov 94
    <dd>Rewrite (fgmr); now based on GNU autoconf
</dl>

<pre>
#ifndef LIB_SYSDEF_H
#define LIB_SYSDEF_H
</pre>

<h2>Configuration master</h2>
<p>The <tt>config.h</tt> file is generated by the <tt>configure</tt> script.</p>

<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif
</pre>

<h2>Include Files</h2>
<p>This file includes all system header files that are needed, iff they exist.
Their existance is discovered by <tt>configure</tt>.</p>
<pre>
/* Include files */

/* stdio.h */
#ifdef HAVE_STDIO_H
# include &lt;stdio.h&gt;
#endif

/* types.h */
#ifdef HAVE_SYS_TYPES_H
# include &lt;sys/types.h&gt;
#else
# ifdef HAVE_TYPES_H
#  include &lt;types.h&gt;
# endif
#endif

/* unistd.h */
#ifdef HAVE_SYS_UNISTD_H
# include &lt;sys/unistd.h&gt;
#else
# ifdef HAVE_UNISTD_H
#  include &lt;unistd.h&gt;
# endif
#endif

/* winsock.h */
#ifdef HAVE_WINSOCK_H
# include &lt;winsock.h&gt;
#endif

/* fcntl.h */
#ifdef HAVE_SYS_FCNTL_H
# include &lt;sys/fcntl.h&gt;
#else
# ifdef HAVE_FCNTL_H
#  include &lt;fcntl.h&gt;
# endif
#endif

/* limits.h */
#ifdef HAVE_SYS_LIMITS_H
# include &lt;sys/limits.h&gt;
#else
# ifdef HAVE_LIMITS_H
#  include &lt;limits.h&gt;
# endif
#endif

/* stat.h */
#ifdef HAVE_SYS_STAT_H
# include &lt;sys/stat.h&gt;
#else
# ifdef HAVE_STAT_H
#  include &lt;stat.h&gt;
# endif
#endif

/* file.h */
#ifdef HAVE_SYS_FILE_H
# include &lt;sys/file.h&gt;
#endif

/* ioctl.h */
#ifdef HAVE_SYS_IOCTL_H
# include &lt;sys/ioctl.h&gt;
#endif

/* time.h */
#ifdef TIME_WITH_SYS_TIME
# include &lt;sys/time.h&gt;
# include &lt;time.h&gt;
#else
# ifdef HAVE_SYS_TIME_H
#  include &lt;sys/time.h&gt;
# else
#  ifdef HAVE_TIME_H
#   include &lt;time.h&gt;
#  endif
# endif
#endif

/* string{,s}.h */
#ifdef HAVE_STRING_H
# include &lt;string.h&gt;
#endif
#ifdef HAVE_STRINGS_H
# include &lt;strings.h&gt;
#endif

/* syslog.h */
#ifdef HAVE_SYSLOG_H
# include &lt;syslog.h&gt;
#endif

/* socket.h */
#ifdef HAVE_SYS_SOCKET_H
# include &lt;sys/socket.h&gt;
#else
# ifdef HAVE_SOCKET_H
#  include &lt;socket.h&gt;
# endif
#endif

/* MacSockDefs.h */
#ifndef NO_SOCKET_DEFS
# ifdef HAVE_MACKSOCKDEFS_H
#  include &lt;MacSockDefs.h&gt;
# endif
#endif

/* socket.ext.h */
#ifdef HAVE_SOCKET_EXT_H
# include &lt;socket.ext.h&gt;
#endif

/* appkit.h */
#ifdef HAVE_APPKIT_APPKIT_H
# include <appkit/appkit.h>
#else
# ifdef HAVE_APPKIT_H
#  include <appkit.h>
# endif
#endif

/* in.h */
#ifdef HAVE_NETINET_IN_H
# include &lt;netinet/in.h&gt;
#else
# ifdef HAVE_IN_H
#  include &lt;in.h&gt;
# endif
#endif

/* dn.h */
#ifdef HAVE_DN_H
# include &lt;dn.h&gt;
#endif

/* ipc.h */
#ifdef HAVE_SYS_IPC_H
# include &lt;sys/ipc.h&gt;
#endif

/* errno.h */
#ifdef HAVE_ERRNO_H
# include &lt;errno.h&gt;
#else
# ifdef HAVE_SYS_ERRNO_H
#  include &lt;sys/errno.h&gt;
# else
#  ifdef HAVE_NET_ERRNO_H
#   include &lt;net/errno.h&gt;
#  endif
# endif
#endif

/* pwd.h */
#ifdef HAVE_PWD_H
# include &lt;pwd.h&gt;
#endif

/* grp.h */
#ifdef HAVE_GRP_H
# include &lt;grp.h&gt;
#endif

/* inet.h */
#ifdef HAVE_ARPA_INET_H
# include &lt;arpa/inet.h&gt;
#else
# ifdef HAVE_INET_H
#  include &lt;inet.h&gt;
# endif
#endif

/* netdb.h */
#ifdef HAVE_NETDB_H
# include &lt;netdb.h&gt;
#endif

/* manifest.h */
#ifdef HAVE_MANIFEST_H
# include &lt;manifest.h&gt;
#endif

/* bsdtypes.h */
#ifdef HAVE_BSDTYPES_H
# include &lt;bsdtypes.h&gt;
#endif

/* stdefs.h */
#ifdef HAVE_STDEFS_H
# include &lt;stdefs.h&gt;
#endif

/* bsdtime.h */
#ifdef HAVE_BSDTIME_H
# include &lt;bsdtime.h&gt;
#endif

/* select.h */
#ifdef HAVE_SYS_SELECT_H
# include &lt;sys/select.h&gt;
#else
# ifdef HAVE_SELECT_H
#  include &lt;select.h&gt;
# endif
#endif

/* dnetdb.h */
#ifdef HAVE_DNETDB_H
# include &lt;dnetdb.h&gt;
#endif

/* ucx$inetdef.h */
#ifdef HAVE_UCX_INETDEF_H
# include &lt;ucx$inetdef.h&gt;
#endif

/* windef.h */
#ifdef HAVE_WINDEF_H
# include &lt;windef.h&gt;
#endif

/* libc.h */
#ifdef HAVE_LIBC_H
# include &lt;libc.h&gt;
#endif

/* stdlib.h */
#ifdef HAVE_STDLIB_H
# include &lt;stdlib.h&gt;
#endif

/* malloc.h */
#ifdef HAVE_MALLOC_H
# include &lt;malloc.h&gt;
#endif

/* memory.h */
#ifdef HAVE_MEMORY_H
# include &lt;memory.h&gt;
#endif

/* unixlib.h */
#ifdef HAVE_UNIXLIB_H
# include &lt;unixlib.h&gt;
#endif

/* ctype.h */
#ifdef HAVE_CTYPE_H
# include &lt;ctype.h&gt;
#endif

/* curses.h */
#ifdef CURSES
# ifdef HAVE_CURSESX_H
#  include &lt;cursesX.h&gt;
# else
#  ifdef HAVE_CURSES_H
#   include &lt;curses.h&gt;
#  endif
# endif
#endif

/* resource.h (some wait.h's require it) */
#ifdef HAVE_SYS_RESOURCE_H
# include &lt;sys/resource.h&gt;
#else
# ifdef HAVE_RESOURCE_H
#  include &lt;resource.h&gt;
# endif
#endif

/* dirent.h / ndir.h / dir.h */
#ifdef HAVE_DIRENT_H
# include &lt;dirent.h&gt;
# define NAMLEN(dirent) strlen((dirent)->d_name)
#else
# define dirent direct
# define NAMLEN(dirent) (dirent)->d_namlen
# ifdef HAVE_SYS_NDIR_H
#  include &lt;sys/ndir.h&gt;
# endif
# ifdef HAVE_SYS_DIR_H
#  include &lt;sys/dir.h&gt;
# endif
# ifdef HAVE_DIR_H
#  include &lt;dir.h&gt;
# endif
# ifdef HAVE_NDIR_H
#  include &lt;ndir.h&gt;
# endif
#endif

#ifndef HAVE_STRCHR
# define strchr index
# define strrchr rindex
#endif
#ifndef HAVE_MEMCPY
# define memcpy(d, s, n) bcopy((s), (d), (n))
# define memmove(d, s, n) bcopy((s), (d), (n))
#endif

/* Standard headers */
#ifdef STDC_HEADERS
# include &lt;stdarg.h&gt;
#else
# include &lt;varargs.h&gt;
#endif

/* wait.h */
#ifdef HAVE_SYS_WAIT_H
# include &lt;sys/wait.h&gt;
#endif
#ifndef WEXITSTATUS
# define WEXITSTATUS(stat_val) (((unsigned)(stat_val) &gt;&gt; 8) &amp 255)
#endif
#ifndef WIFEXITED
# define WIFEXITED(stat_val) (((stat_val) &amp; 255) == 0)
#endif
</pre>

<h2>Network functions</h2>

<p>Some non-unix systems have slightly different versions of the network
access routines.</p>

<h3>Macintosh</h3>
<h4>Think-C</h4>

<pre>
#ifdef THINK_C
# define NETCLOSE    s_close
# define NETREAD     s_read
# define NETWRITE    s_write
# define bind        s_bind
# define connect     s_connect
# define accept      s_accept
# define listen      s_listen
# define socket      s_socket
# define getsockname s_getsockname
#endif
</pre>

<h4>MPW</h4>

<pre>
#ifdef applec   /* == MPW */
# define NETCLOSE s_close
# define NETREAD  s_read
# define NETWRITE s_write
#endif
</pre>

<h3>IBM-PC</h3>
<h4>Windows/NT</h4>
<p>This information was contributed by Susan C. Weber 
&lt;sweber@kyle.eitech.com&gt;.</p>

<pre>
#ifdef _WINDOWS
# define NETCLOSE(s)     ((s)>10 ? closesocket(s)      : close(s)          )
# define NETREAD(s,b,l)  ((s)>10 ? recv((s),(b),(l),0) : read((s),(b),(l)) )
# define NETWRITE(s,b,l) ((s)>10 ? send((s),(b),(l),0) : write((s),(b),(l)))
#endif
</pre>

<h3>VMS</h3>
<p>Under VMS, there are many versions of TCP/IP.  Define one of the following
if you do not use Digital's UCX product:</p>

<dl>
    <dt>MULTINET
    <dd>From SRI, now from TGV Inc.

    <dt>WIN_TCP
    <dd>From Wollongong, now GEC software.

    <dt>DECNET
    <dd>CERN's TCP socket emulation over DECNET.

    <dt>UCX
    <dd>DEC's "Ultrix connection" (default).
</dl>

<pre>
#ifdef VMS
# ifdef MULTINET
#  define NETCLOSE(s)     ((s)&gt;10?socket_close(s)          :close(s)          )
#  define NETREAD(s,b,l)  ((s)&gt;10?socket_read ((s),(b),(l)):read ((s),(b),(l)))
#  define NETWRITE(s,b,l) ((s)&gt;10?socket_write((s),(b),(l)):write((s),(b),(l)))
# else
#  ifdef WIN_TCP
#   define NETCLOSE(s)     ((s)&gt;10?netclose(s)          :close(s)          )
#   define NETREAD(s,b,l)  ((s)&gt;10?netread ((s),(b),(l)):read ((s),(b),(l)))
#   define NETWRITE(s,b,l) ((s)&gt;10?netwrite((s),(b),(l)):write((s),(b),(l)))
#  else
#   ifdef DECNET
#    define NETCLOSE(s)     ((s)&gt;10?socket_close(s)  :close(s)          )
#    define NETREAD(s,b,l)  ((s)&gt;10?recv((s),(b),(l)):read ((s),(b),(l)))
#    define NETWRITE(s,b,l) ((s)&gt;10?send((s),(b),(l)):write((s),(b),(l)))
#   else
#    /* UCX */
#     define NETCLOSE close
#     define NETREAD  read
#     define NETWRITE write
#    /* UCX */
#   endif /* DECNET */
#  endif /* WIN_TCP */
# endif /* MULTINET */
#endif /* VMS */
</pre>

<h3>Unix</h3>
<p>These are the defaults.</p>

<pre>
#ifndef NETCLOSE
# define NETCLOSE close
# define NETREAD  read
# define NETWRITE write
#endif
</pre>

<h2>Telnet, rlogin, and tn3270 access</h2>

<p>This gets confusing.  If <tt>configure</tt> (or a person pretending to be
<tt>configure</tt> has #define'd <i>protocol</i><tt>_PROGRAM</tt> to be the
name of the program (e.g., <tt>telnet</tt>), then we #define 
<i>protocol</i><tt>_COMMAND</tt> to be the <tt>sprintf</tt> call needed to
create the command line.  VMS is always different with its argument handling,
so it (in two cases -- with Multinet and without) is handled specially; VM
only accepts a simple telnet, so it is special; and finally, some Unix&tm;
versions of <tt>telnet</tt> accept the specification of the username on the
command line.  This latter is found by <tt>configure</tt>.</p>

<pre>
#ifdef TELNET_PROGRAM
# ifdef VMS
#  ifdef MULTINET
#   define TELNET_COMMAND(command, user, host, port) \
     sprintf(command, "%s%s%s %s", TELNET_PROGRAM, (port) ? "/port=" : "", \
             (port) ? (port) : "", host)
#  else
#   define TELNET_COMMAND(command, user, host, port) \
     sprintf(command, "%s %s", TELNET_PROGRAM, host)
#  endif
# else /* Not VMS */
#  ifdef VM
#   define TELNET_COMMAND(command, user, host, port) \
     sprintf(command, "%s %s", TELNET_PROGRAM, host)
#  else /* Not VM */
#   ifdef TELNET_MINUS_L
#    define TELNET_COMMAND(command, user, host, port) \
      sprintf(command, "%s%s%s %s %s", TELNET_PROGRAM, (user) ? " -l " : "", \
              (user) ? (user) : "", host, (port) ? (port) : "")
#   else
#    define TELNET_COMMAND(command, user, host, port) \
      sprintf(command, "%s %s %s", TELNET_PROGRAM, host, (port) ? (port) : "")
#   endif
#  endif
# endif
#endif /* TELNET_PROGRAM */

#ifdef RLOGIN_PROGRAM
# ifdef VMS
#  ifdef MULTINET
#   define RLOGIN_COMMAND(command, user, host, port) \
     sprintf(command, "%s%s%s%s%s %s", RLOGIN_PROGRAM, (user) ? "/username=" \
             : "", (user) ? (user) : "", (port) ? "/port=" : "", (port) ? \
             (port) : "", host)
#  else /* VMS, but not MULTINET */
#   define RLOGIN_COMMAND(command, user, host, port) \
     sprintf(command, "%s %s", RLOGIN_PROGRAM, host)
#  endif
# else /* Not VMS */
#  define RLOGIN_COMMAND(command, user, host, port) \
    sprintf(command, "%s%s%s %s %s", RLOGIN_PROGRAM, (user) ? " -l " : "", \
            (user) ? (user) : "", host, port)
# endif
#endif /* RLOGIN_PROGRAM */

#ifdef TN3270_PROGRAM
# ifdef VMS
#  ifdef MULTINET
#   define TN3270_COMMAND(command, user, host, port) \
     sprintf(command, "%s%s%s %s", TN3270_PROGRAM, (port) ? "/port=" : "", \
             (port) ? (port) : "", host)
#  else /* VMS, but not MULTINET */
#   define TN3270_COMMAND(command, user, host, port) \
     sprintf(command, "%s %s", TN3270_PROGRAM, host)
#  endif
# else /* Not VMS */
#  define TN3270_COMMAND(command, user, host, port) \
    sprintf(command, "%s %s %s", TN3270_PROGRAM, host, port)
# endif
#endif /* TN3270_PROGRAM */
</pre>

<h2>Socket Address type</h2>

<pre>
#if defined(VMS) && defined(DECNET)
typedef struct sockaddr_dn SockA;
#else 
typedef struct sockaddr_in SockA;
#endif
</pre>

<h2>Standard IO File Descriptors</h2>

<pre>
#ifndef STDIN_FILENO
#define STDIN_FILENO 0
#endif

#ifndef STDOUT_FILENO
#define STDOUT_FILENO 1
#endif

#ifndef STDERR_FILENO
#define STDERR_FILENO 2
#endif
</pre>

<h2>File Descriptor Set Handling</h2>

<pre>
#ifndef FD_SET
# define FD_SET(fd, m) (*(unsigned*)(m) |=  (1 &lt;&lt; (fd)))
#endif
#ifndef FD_CLR
# define FD_CLR(fd, m) (*(unsigned*)(m) &amp;= ~(1 &lt;&lt; (fd)))
#endif
#ifndef FD_ZERO
# define FD_ZERO(m)    (*(unsigned*)(m)) = 0
#endif
#ifndef FD_ISSET
# define FD_ISSET(fd, m) (*(unsigned*)(m) &amp; (1 &lt;&lt; (fd)))
#endif
</pre>

<h2>File Permissions</h2>

<pre>
#ifndef S_IRWXU
# define S_IRWXU 0000700
# define S_IRUSR 0000400
# define S_IWUSR 0000200
# define S_IXUSR 0000100
# define S_IRWXG 0000070
# define S_IRGRP 0000040
# define S_IWGRP 0000020
# define S_IXGRP 0000010
# define S_IRWXO 0000007
# define S_IROTH 0000004
# define S_IWOTH 0000002
# define S_IXOTH 0000001
# define S_ISUID 0004000
# define S_ISGID 0002000
# define S_ISVTX 0001000
#endif
</pre>

<h2>File Types</h2>

<pre>
#ifndef S_IFMT
# define S_IFMT  0xf000
#endif
#ifndef S_IFIFO
# define S_IFIFO 0x1000
#endif
#ifndef S_IFCHR
# define S_IFCHR 0x2000
#endif
#ifndef S_IFDIR
# define S_IFDIR 0x4000
#endif
#ifndef S_IFNAM
# define S_IFNAM 0x5000
#endif
#ifndef S_IFBLK
# define S_IFBLK 0x6000
#endif
#ifndef S_IFREG
# define S_IFREG 0x8000
#endif
#ifndef S_IFLNK
# define S_IFLNK 0xa000
#endif
#ifndef S_IFSOCK
# define S_IFSOCK 0xc000
#endif
</pre>

<p>On some platforms, the macros S_ISDIR, S_ISREG, et.al. don't work (see
the GNU Autoconf documentation for more details).  In these cases, we prefer
our own.</p>
<pre>
#ifdef STAT_MACROS_BROKEN
# ifdef S_ISFIFO
#  undef S_ISFIFO
# endif
# ifdef S_ISCHR
#  undef S_ISCHR
# endif
# ifdef S_ISDIR
#  undef S_ISDIR
# endif
# ifdef S_ISNAM
#  undef S_ISNAM
# endif
# ifdef S_ISBLK
#  undef S_ISBLK
# endif
# ifdef S_ISREG
#  undef S_ISREG
# endif
# ifdef S_ISLNK
#  undef S_ISLNK
# endif
# ifdef S_ISSOCK
#  undef S_ISSOCK
# endif
#endif

#ifndef S_ISFIFO
# define S_ISFIFO(m) (((m) &amp; S_IFMT) == S_IFIFO)
#endif
#ifndef S_ISCHR
# define S_ISCHR(m)  (((m) &amp; S_IFMT) == S_IFCHR)
#endif
#ifndef S_ISDIR
# define S_ISDIR(m)  (((m) &amp; S_IFMT) == S_IFDIR)
#endif
#ifndef S_ISNAM
# define S_ISNAM(m)  (((m) &amp; S_IFMT) == S_IFNAM)
#endif
#ifndef S_ISBLK
# define S_ISBLK(m)  (((m) &amp; S_IFMT) == S_IFBLK)
#endif
#ifndef S_ISREG
# define S_ISREG(m)  (((m) &amp; S_IFMT) == S_IFREG)
#endif
#ifndef S_ISLNK
# define S_ISLNK(m)  (((m) &amp; S_IFMT) == S_IFLNK)
#endif
#ifndef S_ISSOCK
# define S_ISSOCK(m) (((m) &amp; S_IFMT) == S_IFSOCK)
#endif
</pre>

<h2>Memory allocation</h2>
<p>On VAXC we should use the VAXC$ routines, which are optimized.  On PCs,
we *should* implement some sort of fail-safe memory allocation scheme,
because memory leaks persist beyond process termination.</p>

<pre>
#ifdef VAXC
# define malloc  VAXC$MALLOC_OPT
# define calloc  VAXC$CALLOC_OPT
# define free    VAXC$FREE_OPT
# define cfree   VAXC$CFREE_OPT
# define realloc VAXC$REALLOC_OPT
#endif
#ifdef _WINDOWS
/* ... */
#endif
</pre>

<h2>Other occasionally missing constants</h2>

<pre>
#ifndef X_OK
# define X_OK 1
#endif
#ifndef R_OK
# define R_OK 4
#endif
#ifndef S_ENFMT
# define S_ENFMT S_ISGID
#endif
#ifndef FNDELAY
# define FNDELAY O_NDELAY
#endif
#ifndef MAXHOSTNAMELEN
# define MAXHOSTNAMELEN 64
#endif
#ifndef NGROUPS
# ifdef NGROUPS_MAX
#  define NGROUPS NGROUPS_MAX
# else
#  define NGROUPS 20
# endif
#endif
#ifndef HT_MAX_PATH
# ifdef MAXPATHLEN
#  define HT_MAX_PATH MAXPATHLEN
# else
#  ifdef PATH_MAX
#   define HT_MAX_PATH PATH_MAX
#  else
#   define HT_MAX_PATH 1024
#  endif
# endif
#endif
#ifndef L_tmpnam
# define L_tmpnam 64
#endif
#ifndef FD_SETSIZE
# ifdef MULTINET
#  define FD_SETSIZE 256
# else
#  define FD_SETSIZE 32
# endif
#endif
#ifndef SIGCLD
# ifdef SIGCHLD
#  define SIGCLD SIGCHLD
# endif
#endif
#ifdef VM
# ifdef ECONNRESET
#  undef ECONNRESET
# endif
# define ECONNRESET 69
#endif
</pre>

<h2>SOCKS</h2>
<p>SOCKS is a package for allowing socket connections to tunnel through
firewalls in carefully controlled situations.  This package can be
optionally compiled with SOCKS support; these definitions replace the
normal socket calls with the SOCKS ones.  Initial modification of the
library is credited to Ian Dunkin &lt;imd1707@ggr.co.uk&gt;.</p>

<pre>
#ifdef SOCKS
# ifndef connect  /* Macintosh Think-C also redefines these! */
#  define connect     Rconnect
#  define accept      Raccept
#  define getsockname Rgetsockname
#  define bind        Rbind
#  define listen      Rlisten
# else
/* Now what? */
#  define SOCKSinit(s) puts("SOCKS is not supported on this platform.")
# endif
#endif
</pre>

<h2>ASCII or EBCDIC</h2>

<pre>
#ifdef NOT_ASCII
extern char asciitoebcdic[], ebcdictoascii[];
# define TOASCII(c)   (c=='\n' ? 10 : ebcdictoascii[c])
# define FROMASCII(c) (c==10 ? '\n' : asciitoebcdic[c])
# define WHITE(c)     (((unsigned char)(TOASCII(c))) &lt;= 32)
#else
# define TOASCII(c)   (c)
# define FROMASCII(c) (c)
# define WHITE(c)     (((unsigned char)((c) &lt;= 32)))
#endif
</pre>

<h2>Miscellaneous</h2>
<p>There are always a couple random platform-specific things that don't
really have cross-platform analogs...</p>

<pre>
#ifdef VMS
# include "HTVMSUtils.h"
#endif
</pre>

<p>Macintosh with MPW -- to be honest, I don't really know what these
defines are for.</p>

<pre>
#ifdef applec
# define GUI
# define LINEFEED 10
# define ANON_FTP_HOSTNAME
#endif
</pre>

<p>IBM VM: Enable recursive newlib</p>

<pre>
#ifdef VM
# pragma linkage(newlib,OS)
#endif
</pre>

<p>On VMS machines, the linker needs to be told to put global data sections
into a data segment using these storage classes.  (Mark Donszelmann)</p>

<pre>
#ifdef VAXC
# define GLOBALDEF globaldef
# define GLOBALREF globalref
#else
# define GLOBALDEF
# define GLOBALREF extern
#endif
</pre>

<p>On non-VMS machines, HTStat should be stat.  On VMS machines, HTStat is
a function that converts directories and devices so that one can stat them.
PCs don't have symbolic links.</p>

<pre>
#ifdef VMS
# define HTLstat HTStat
#else
# ifdef HAVE_SYMLINK
#  define HTStat stat
#  define HTLstat lstat
# else
#  define HTStat  stat
#  define HTLstat stat
# endif
#endif
</pre>

<p>This one platform -- UTS 2.1 -- seems to have a weird exit status:</p>

<pre>
#ifdef UTS2
# undef WEXITSTATUS
# define WEXITSTATUS(x) ((int)(x).w_T.w_Retcode))
#endif
</pre>

<h2>The End.</h2>

<pre>
#endif /* LIB_SYSDEF_H */
</pre>

</body>
</html>
