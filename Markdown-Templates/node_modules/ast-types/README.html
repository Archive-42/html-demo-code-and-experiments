<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="ast-types-build-status-greenkeeper-badge">AST Types <a href="https://travis-ci.org/benjamn/ast-types"><img src="https://travis-ci.org/benjamn/ast-types.svg?branch=master" alt="Build Status" /></a> <a href="https://greenkeeper.io/"><img src="https://badges.greenkeeper.io/benjamn/ast-types.svg" alt="Greenkeeper badge" /></a></h1>
<p>This module provides an efficient, modular, <a href="https://github.com/ariya/esprima">Esprima</a>-compatible implementation of the <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> type hierarchy pioneered by the <a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API">Mozilla Parser API</a>.</p>
<h2 id="installation">Installation</h2>
<p>From NPM:</p>
<pre><code>npm install ast-types</code></pre>
<p>From GitHub:</p>
<pre><code>cd path/to/node_modules
git clone git://github.com/benjamn/ast-types.git
cd ast-types
npm install .</code></pre>
<h2 id="basic-usage">Basic Usage</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="im">import</span> assert <span class="im">from</span> <span class="st">&quot;assert&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="im">import</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-3" title="3">  namedTypes <span class="im">as</span> n<span class="op">,</span></a>
<a class="sourceLine" id="cb3-4" title="4">  builders <span class="im">as</span> b<span class="op">,</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="op">}</span> <span class="im">from</span> <span class="st">&quot;ast-types&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="kw">var</span> fooId <span class="op">=</span> <span class="va">b</span>.<span class="at">identifier</span>(<span class="st">&quot;foo&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="kw">var</span> ifFoo <span class="op">=</span> <span class="va">b</span>.<span class="at">ifStatement</span>(fooId<span class="op">,</span> <span class="va">b</span>.<span class="at">blockStatement</span>([</a>
<a class="sourceLine" id="cb3-9" title="9">  <span class="va">b</span>.<span class="at">expressionStatement</span>(<span class="va">b</span>.<span class="at">callExpression</span>(fooId<span class="op">,</span> []))</a>
<a class="sourceLine" id="cb3-10" title="10">]))<span class="op">;</span></a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="va">assert</span>.<span class="at">ok</span>(<span class="va">n</span>.<span class="va">IfStatement</span>.<span class="at">check</span>(ifFoo))<span class="op">;</span></a>
<a class="sourceLine" id="cb3-13" title="13"><span class="va">assert</span>.<span class="at">ok</span>(<span class="va">n</span>.<span class="va">Statement</span>.<span class="at">check</span>(ifFoo))<span class="op">;</span></a>
<a class="sourceLine" id="cb3-14" title="14"><span class="va">assert</span>.<span class="at">ok</span>(<span class="va">n</span>.<span class="va">Node</span>.<span class="at">check</span>(ifFoo))<span class="op">;</span></a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16"><span class="va">assert</span>.<span class="at">ok</span>(<span class="va">n</span>.<span class="va">BlockStatement</span>.<span class="at">check</span>(<span class="va">ifFoo</span>.<span class="at">consequent</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb3-17" title="17"><span class="va">assert</span>.<span class="at">strictEqual</span>(</a>
<a class="sourceLine" id="cb3-18" title="18">  <span class="va">ifFoo</span>.<span class="va">consequent</span>.<span class="at">body</span>[<span class="dv">0</span>].<span class="va">expression</span>.<span class="va">arguments</span>.<span class="at">length</span><span class="op">,</span></a>
<a class="sourceLine" id="cb3-19" title="19">  <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb3-20" title="20">)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-21" title="21"></a>
<a class="sourceLine" id="cb3-22" title="22"><span class="va">assert</span>.<span class="at">strictEqual</span>(<span class="va">ifFoo</span>.<span class="at">test</span><span class="op">,</span> fooId)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-23" title="23"><span class="va">assert</span>.<span class="at">ok</span>(<span class="va">n</span>.<span class="va">Expression</span>.<span class="at">check</span>(<span class="va">ifFoo</span>.<span class="at">test</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb3-24" title="24"><span class="va">assert</span>.<span class="at">ok</span>(<span class="va">n</span>.<span class="va">Identifier</span>.<span class="at">check</span>(<span class="va">ifFoo</span>.<span class="at">test</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb3-25" title="25"><span class="va">assert</span>.<span class="at">ok</span>(<span class="op">!</span><span class="va">n</span>.<span class="va">Statement</span>.<span class="at">check</span>(<span class="va">ifFoo</span>.<span class="at">test</span>))<span class="op">;</span></a></code></pre></div>
<h2 id="ast-traversal">AST Traversal</h2>
<p>Because it understands the AST type system so thoroughly, this library is able to provide excellent node iteration and traversal mechanisms.</p>
<p>If you want complete control over the traversal, and all you need is a way of enumerating the known fields of your AST nodes and getting their values, you may be interested in the primitives <code>getFieldNames</code> and <code>getFieldValue</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="im">import</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">  getFieldNames<span class="op">,</span></a>
<a class="sourceLine" id="cb4-3" title="3">  getFieldValue<span class="op">,</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="op">}</span> <span class="im">from</span> <span class="st">&quot;ast-types&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">const</span> partialFunExpr <span class="op">=</span> <span class="op">{</span> <span class="dt">type</span><span class="op">:</span> <span class="st">&quot;FunctionExpression&quot;</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co">// Even though partialFunExpr doesn&#39;t actually contain all the fields that</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="co">// are expected for a FunctionExpression, types.getFieldNames knows:</span></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="va">console</span>.<span class="at">log</span>(<span class="at">getFieldNames</span>(partialFunExpr))<span class="op">;</span></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co">// [ &#39;type&#39;, &#39;id&#39;, &#39;params&#39;, &#39;body&#39;, &#39;generator&#39;, &#39;expression&#39;,</span></a>
<a class="sourceLine" id="cb4-12" title="12"><span class="co">//   &#39;defaults&#39;, &#39;rest&#39;, &#39;async&#39; ]</span></a>
<a class="sourceLine" id="cb4-13" title="13"></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co">// For fields that have default values, types.getFieldValue will return</span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="co">// the default if the field is not actually defined.</span></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="va">console</span>.<span class="at">log</span>(<span class="at">getFieldValue</span>(partialFunExpr<span class="op">,</span> <span class="st">&quot;generator&quot;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb4-17" title="17"><span class="co">// false</span></a></code></pre></div>
<p>Two more low-level helper functions, <code>eachField</code> and <code>someField</code>, are defined in terms of <code>getFieldNames</code> and <code>getFieldValue</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// Iterate over all defined fields of an object, including those missing</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">// or undefined, passing each field name and effective value (as returned</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co">// by getFieldValue) to the callback. If the object has no corresponding</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="co">// Def, the callback will never be called.</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="im">export</span> <span class="kw">function</span> <span class="at">eachField</span>(object<span class="op">,</span> callback<span class="op">,</span> context) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="at">getFieldNames</span>(object).<span class="at">forEach</span>(<span class="kw">function</span>(name) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="va">callback</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span> name<span class="op">,</span> <span class="at">getFieldValue</span>(object<span class="op">,</span> name))<span class="op">;</span></a>
<a class="sourceLine" id="cb5-8" title="8">  <span class="op">},</span> context)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="op">}</span></a>
<a class="sourceLine" id="cb5-10" title="10"></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="co">// Similar to eachField, except that iteration stops as soon as the</span></a>
<a class="sourceLine" id="cb5-12" title="12"><span class="co">// callback returns a truthy value. Like Array.prototype.some, the final</span></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="co">// result is either true or false to indicates whether the callback</span></a>
<a class="sourceLine" id="cb5-14" title="14"><span class="co">// returned true for any element or not.</span></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="im">export</span> <span class="kw">function</span> <span class="at">someField</span>(object<span class="op">,</span> callback<span class="op">,</span> context) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-16" title="16">  <span class="cf">return</span> <span class="at">getFieldNames</span>(object).<span class="at">some</span>(<span class="kw">function</span>(name) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="cf">return</span> <span class="va">callback</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span> name<span class="op">,</span> <span class="at">getFieldValue</span>(object<span class="op">,</span> name))<span class="op">;</span></a>
<a class="sourceLine" id="cb5-18" title="18">  <span class="op">},</span> context)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-19" title="19"><span class="op">}</span></a></code></pre></div>
<p>So here’s how you might make a copy of an AST node:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="im">import</span> <span class="op">{</span> eachField <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;ast-types&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">const</span> copy <span class="op">=</span> <span class="op">{};</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="at">eachField</span>(node<span class="op">,</span> <span class="kw">function</span>(name<span class="op">,</span> value) <span class="op">{</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="co">// Note that undefined fields will be visited too, according to</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="co">// the rules associated with node.type, and default field values</span></a>
<a class="sourceLine" id="cb6-6" title="6">  <span class="co">// will be substituted if appropriate.</span></a>
<a class="sourceLine" id="cb6-7" title="7">  copy[name] <span class="op">=</span> value<span class="op">;</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="op">}</span>)</a></code></pre></div>
<p>But that’s not all! You can also easily visit entire syntax trees using the powerful <code>types.visit</code> abstraction.</p>
<p>Here’s a trivial example of how you might assert that <code>arguments.callee</code> is never used in <code>ast</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="im">import</span> assert <span class="im">from</span> <span class="st">&quot;assert&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="im">import</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-3" title="3">  visit<span class="op">,</span></a>
<a class="sourceLine" id="cb7-4" title="4">  namedTypes <span class="im">as</span> n<span class="op">,</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="op">}</span> <span class="im">from</span> <span class="st">&quot;ast-types&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="at">visit</span>(ast<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-8" title="8">  <span class="co">// This method will be called for any node with .type &quot;MemberExpression&quot;:</span></a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="at">visitMemberExpression</span>(path) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-10" title="10">    <span class="co">// Visitor methods receive a single argument, a NodePath object</span></a>
<a class="sourceLine" id="cb7-11" title="11">    <span class="co">// wrapping the node of interest.</span></a>
<a class="sourceLine" id="cb7-12" title="12">    <span class="kw">var</span> node <span class="op">=</span> <span class="va">path</span>.<span class="at">node</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14">    <span class="cf">if</span> (</a>
<a class="sourceLine" id="cb7-15" title="15">      <span class="va">n</span>.<span class="va">Identifier</span>.<span class="at">check</span>(<span class="va">node</span>.<span class="at">object</span>) <span class="op">&amp;&amp;</span></a>
<a class="sourceLine" id="cb7-16" title="16">      <span class="va">node</span>.<span class="va">object</span>.<span class="at">name</span> <span class="op">===</span> <span class="st">&quot;arguments&quot;</span> <span class="op">&amp;&amp;</span></a>
<a class="sourceLine" id="cb7-17" title="17">      <span class="va">n</span>.<span class="va">Identifier</span>.<span class="at">check</span>(<span class="va">node</span>.<span class="at">property</span>)</a>
<a class="sourceLine" id="cb7-18" title="18">    ) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-19" title="19">      <span class="va">assert</span>.<span class="at">notStrictEqual</span>(<span class="va">node</span>.<span class="va">property</span>.<span class="at">name</span><span class="op">,</span> <span class="st">&quot;callee&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-20" title="20">    <span class="op">}</span></a>
<a class="sourceLine" id="cb7-21" title="21"></a>
<a class="sourceLine" id="cb7-22" title="22">    <span class="co">// It&#39;s your responsibility to call this.traverse with some</span></a>
<a class="sourceLine" id="cb7-23" title="23">    <span class="co">// NodePath object (usually the one passed into the visitor</span></a>
<a class="sourceLine" id="cb7-24" title="24">    <span class="co">// method) before the visitor method returns, or return false to</span></a>
<a class="sourceLine" id="cb7-25" title="25">    <span class="co">// indicate that the traversal need not continue any further down</span></a>
<a class="sourceLine" id="cb7-26" title="26">    <span class="co">// this subtree.</span></a>
<a class="sourceLine" id="cb7-27" title="27">    <span class="kw">this</span>.<span class="at">traverse</span>(path)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-28" title="28">  <span class="op">}</span></a>
<a class="sourceLine" id="cb7-29" title="29"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Here’s a slightly more involved example of transforming <code>...rest</code> parameters into browser-runnable ES5 JavaScript:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="im">import</span> <span class="op">{</span> builders <span class="im">as</span> b<span class="op">,</span> visit <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;ast-types&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">// Reuse the same AST structure for Array.prototype.slice.call.</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">var</span> sliceExpr <span class="op">=</span> <span class="va">b</span>.<span class="at">memberExpression</span>(</a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="va">b</span>.<span class="at">memberExpression</span>(</a>
<a class="sourceLine" id="cb8-6" title="6">    <span class="va">b</span>.<span class="at">memberExpression</span>(</a>
<a class="sourceLine" id="cb8-7" title="7">      <span class="va">b</span>.<span class="at">identifier</span>(<span class="st">&quot;Array&quot;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb8-8" title="8">      <span class="va">b</span>.<span class="at">identifier</span>(<span class="st">&quot;prototype&quot;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb8-9" title="9">      <span class="kw">false</span></a>
<a class="sourceLine" id="cb8-10" title="10">    )<span class="op">,</span></a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="va">b</span>.<span class="at">identifier</span>(<span class="st">&quot;slice&quot;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb8-12" title="12">    <span class="kw">false</span></a>
<a class="sourceLine" id="cb8-13" title="13">  )<span class="op">,</span></a>
<a class="sourceLine" id="cb8-14" title="14">  <span class="va">b</span>.<span class="at">identifier</span>(<span class="st">&quot;call&quot;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb8-15" title="15">  <span class="kw">false</span></a>
<a class="sourceLine" id="cb8-16" title="16">)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-17" title="17"></a>
<a class="sourceLine" id="cb8-18" title="18"><span class="at">visit</span>(ast<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-19" title="19">  <span class="co">// This method will be called for any node whose type is a subtype of</span></a>
<a class="sourceLine" id="cb8-20" title="20">  <span class="co">// Function (e.g., FunctionDeclaration, FunctionExpression, and</span></a>
<a class="sourceLine" id="cb8-21" title="21">  <span class="co">// ArrowFunctionExpression). Note that types.visit precomputes a</span></a>
<a class="sourceLine" id="cb8-22" title="22">  <span class="co">// lookup table from every known type to the appropriate visitor</span></a>
<a class="sourceLine" id="cb8-23" title="23">  <span class="co">// method to call for nodes of that type, so the dispatch takes</span></a>
<a class="sourceLine" id="cb8-24" title="24">  <span class="co">// constant time.</span></a>
<a class="sourceLine" id="cb8-25" title="25">  <span class="at">visitFunction</span>(path) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-26" title="26">    <span class="co">// Visitor methods receive a single argument, a NodePath object</span></a>
<a class="sourceLine" id="cb8-27" title="27">    <span class="co">// wrapping the node of interest.</span></a>
<a class="sourceLine" id="cb8-28" title="28">    <span class="kw">const</span> node <span class="op">=</span> <span class="va">path</span>.<span class="at">node</span><span class="op">;</span></a>
<a class="sourceLine" id="cb8-29" title="29"></a>
<a class="sourceLine" id="cb8-30" title="30">    <span class="co">// It&#39;s your responsibility to call this.traverse with some</span></a>
<a class="sourceLine" id="cb8-31" title="31">    <span class="co">// NodePath object (usually the one passed into the visitor</span></a>
<a class="sourceLine" id="cb8-32" title="32">    <span class="co">// method) before the visitor method returns, or return false to</span></a>
<a class="sourceLine" id="cb8-33" title="33">    <span class="co">// indicate that the traversal need not continue any further down</span></a>
<a class="sourceLine" id="cb8-34" title="34">    <span class="co">// this subtree. An assertion will fail if you forget, which is</span></a>
<a class="sourceLine" id="cb8-35" title="35">    <span class="co">// awesome, because it means you will never again make the</span></a>
<a class="sourceLine" id="cb8-36" title="36">    <span class="co">// disastrous mistake of forgetting to traverse a subtree. Also</span></a>
<a class="sourceLine" id="cb8-37" title="37">    <span class="co">// cool: because you can call this method at any point in the</span></a>
<a class="sourceLine" id="cb8-38" title="38">    <span class="co">// visitor method, it&#39;s up to you whether your traversal is</span></a>
<a class="sourceLine" id="cb8-39" title="39">    <span class="co">// pre-order, post-order, or both!</span></a>
<a class="sourceLine" id="cb8-40" title="40">    <span class="kw">this</span>.<span class="at">traverse</span>(path)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-41" title="41"></a>
<a class="sourceLine" id="cb8-42" title="42">    <span class="co">// This traversal is only concerned with Function nodes that have</span></a>
<a class="sourceLine" id="cb8-43" title="43">    <span class="co">// rest parameters.</span></a>
<a class="sourceLine" id="cb8-44" title="44">    <span class="cf">if</span> (<span class="op">!</span><span class="va">node</span>.<span class="at">rest</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-45" title="45">      <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb8-46" title="46">    <span class="op">}</span></a>
<a class="sourceLine" id="cb8-47" title="47"></a>
<a class="sourceLine" id="cb8-48" title="48">    <span class="co">// For the purposes of this example, we won&#39;t worry about functions</span></a>
<a class="sourceLine" id="cb8-49" title="49">    <span class="co">// with Expression bodies.</span></a>
<a class="sourceLine" id="cb8-50" title="50">    <span class="va">n</span>.<span class="va">BlockStatement</span>.<span class="at">assert</span>(<span class="va">node</span>.<span class="at">body</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-51" title="51"></a>
<a class="sourceLine" id="cb8-52" title="52">    <span class="co">// Use types.builders to build a variable declaration of the form</span></a>
<a class="sourceLine" id="cb8-53" title="53">    <span class="co">//</span></a>
<a class="sourceLine" id="cb8-54" title="54">    <span class="co">//   var rest = Array.prototype.slice.call(arguments, n);</span></a>
<a class="sourceLine" id="cb8-55" title="55">    <span class="co">//</span></a>
<a class="sourceLine" id="cb8-56" title="56">    <span class="co">// where `rest` is the name of the rest parameter, and `n` is a</span></a>
<a class="sourceLine" id="cb8-57" title="57">    <span class="co">// numeric literal specifying the number of named parameters the</span></a>
<a class="sourceLine" id="cb8-58" title="58">    <span class="co">// function takes.</span></a>
<a class="sourceLine" id="cb8-59" title="59">    <span class="kw">const</span> restVarDecl <span class="op">=</span> <span class="va">b</span>.<span class="at">variableDeclaration</span>(<span class="st">&quot;var&quot;</span><span class="op">,</span> [</a>
<a class="sourceLine" id="cb8-60" title="60">      <span class="va">b</span>.<span class="at">variableDeclarator</span>(</a>
<a class="sourceLine" id="cb8-61" title="61">        <span class="va">node</span>.<span class="at">rest</span><span class="op">,</span></a>
<a class="sourceLine" id="cb8-62" title="62">        <span class="va">b</span>.<span class="at">callExpression</span>(sliceExpr<span class="op">,</span> [</a>
<a class="sourceLine" id="cb8-63" title="63">          <span class="va">b</span>.<span class="at">identifier</span>(<span class="st">&quot;arguments&quot;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb8-64" title="64">          <span class="va">b</span>.<span class="at">literal</span>(<span class="va">node</span>.<span class="va">params</span>.<span class="at">length</span>)</a>
<a class="sourceLine" id="cb8-65" title="65">        ])</a>
<a class="sourceLine" id="cb8-66" title="66">      )</a>
<a class="sourceLine" id="cb8-67" title="67">    ])<span class="op">;</span></a>
<a class="sourceLine" id="cb8-68" title="68"></a>
<a class="sourceLine" id="cb8-69" title="69">    <span class="co">// Similar to doing node.body.body.unshift(restVarDecl), except</span></a>
<a class="sourceLine" id="cb8-70" title="70">    <span class="co">// that the other NodePath objects wrapping body statements will</span></a>
<a class="sourceLine" id="cb8-71" title="71">    <span class="co">// have their indexes updated to accommodate the new statement.</span></a>
<a class="sourceLine" id="cb8-72" title="72">    <span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;body&quot;</span><span class="op">,</span> <span class="st">&quot;body&quot;</span>).<span class="at">unshift</span>(restVarDecl)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-73" title="73"></a>
<a class="sourceLine" id="cb8-74" title="74">    <span class="co">// Nullify node.rest now that we have simulated the behavior of</span></a>
<a class="sourceLine" id="cb8-75" title="75">    <span class="co">// the rest parameter using ordinary JavaScript.</span></a>
<a class="sourceLine" id="cb8-76" title="76">    <span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;rest&quot;</span>).<span class="at">replace</span>(<span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-77" title="77"></a>
<a class="sourceLine" id="cb8-78" title="78">    <span class="co">// There&#39;s nothing wrong with doing node.rest = null, but I wanted</span></a>
<a class="sourceLine" id="cb8-79" title="79">    <span class="co">// to point out that the above statement has the same effect.</span></a>
<a class="sourceLine" id="cb8-80" title="80">    <span class="va">assert</span>.<span class="at">strictEqual</span>(<span class="va">node</span>.<span class="at">rest</span><span class="op">,</span> <span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-81" title="81">  <span class="op">}</span></a>
<a class="sourceLine" id="cb8-82" title="82"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Here’s how you might use <code>types.visit</code> to implement a function that determines if a given function node refers to <code>this</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">function</span> <span class="at">usesThis</span>(funcNode) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="va">n</span>.<span class="va">Function</span>.<span class="at">assert</span>(funcNode)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="kw">var</span> result <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5">  <span class="at">visit</span>(funcNode<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="at">visitThisExpression</span>(path) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-7" title="7">      result <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9">      <span class="co">// The quickest way to terminate the traversal is to call</span></a>
<a class="sourceLine" id="cb9-10" title="10">      <span class="co">// this.abort(), which throws a special exception (instanceof</span></a>
<a class="sourceLine" id="cb9-11" title="11">      <span class="co">// this.AbortRequest) that will be caught in the top-level</span></a>
<a class="sourceLine" id="cb9-12" title="12">      <span class="co">// types.visit method, so you don&#39;t have to worry about</span></a>
<a class="sourceLine" id="cb9-13" title="13">      <span class="co">// catching the exception yourself.</span></a>
<a class="sourceLine" id="cb9-14" title="14">      <span class="kw">this</span>.<span class="at">abort</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb9-15" title="15">    <span class="op">},</span></a>
<a class="sourceLine" id="cb9-16" title="16"></a>
<a class="sourceLine" id="cb9-17" title="17">    <span class="at">visitFunction</span>(path) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-18" title="18">      <span class="co">// ThisExpression nodes in nested scopes don&#39;t count as `this`</span></a>
<a class="sourceLine" id="cb9-19" title="19">      <span class="co">// references for the original function node, so we can safely</span></a>
<a class="sourceLine" id="cb9-20" title="20">      <span class="co">// avoid traversing this subtree.</span></a>
<a class="sourceLine" id="cb9-21" title="21">      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-22" title="22">    <span class="op">},</span></a>
<a class="sourceLine" id="cb9-23" title="23"></a>
<a class="sourceLine" id="cb9-24" title="24">    <span class="at">visitCallExpression</span>(path) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-25" title="25">      <span class="kw">const</span> node <span class="op">=</span> <span class="va">path</span>.<span class="at">node</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-26" title="26"></a>
<a class="sourceLine" id="cb9-27" title="27">      <span class="co">// If the function contains CallExpression nodes involving</span></a>
<a class="sourceLine" id="cb9-28" title="28">      <span class="co">// super, those expressions will implicitly depend on the</span></a>
<a class="sourceLine" id="cb9-29" title="29">      <span class="co">// value of `this`, even though they do not explicitly contain</span></a>
<a class="sourceLine" id="cb9-30" title="30">      <span class="co">// any ThisExpression nodes.</span></a>
<a class="sourceLine" id="cb9-31" title="31">      <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">isSuperCallExpression</span>(node)) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-32" title="32">        result <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-33" title="33">        <span class="kw">this</span>.<span class="at">abort</span>()<span class="op">;</span> <span class="co">// Throws AbortRequest exception.</span></a>
<a class="sourceLine" id="cb9-34" title="34">      <span class="op">}</span></a>
<a class="sourceLine" id="cb9-35" title="35"></a>
<a class="sourceLine" id="cb9-36" title="36">      <span class="kw">this</span>.<span class="at">traverse</span>(path)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-37" title="37">    <span class="op">},</span></a>
<a class="sourceLine" id="cb9-38" title="38"></a>
<a class="sourceLine" id="cb9-39" title="39">    <span class="co">// Yes, you can define arbitrary helper methods.</span></a>
<a class="sourceLine" id="cb9-40" title="40">    <span class="at">isSuperCallExpression</span>(callExpr) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-41" title="41">      <span class="va">n</span>.<span class="va">CallExpression</span>.<span class="at">assert</span>(callExpr)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-42" title="42">      <span class="cf">return</span> <span class="kw">this</span>.<span class="at">isSuperIdentifier</span>(<span class="va">callExpr</span>.<span class="at">callee</span>)</a>
<a class="sourceLine" id="cb9-43" title="43">          <span class="op">||</span> <span class="kw">this</span>.<span class="at">isSuperMemberExpression</span>(<span class="va">callExpr</span>.<span class="at">callee</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-44" title="44">    <span class="op">},</span></a>
<a class="sourceLine" id="cb9-45" title="45"></a>
<a class="sourceLine" id="cb9-46" title="46">    <span class="co">// And even helper helper methods!</span></a>
<a class="sourceLine" id="cb9-47" title="47">    <span class="at">isSuperIdentifier</span>(node) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-48" title="48">      <span class="cf">return</span> <span class="va">n</span>.<span class="va">Identifier</span>.<span class="at">check</span>(<span class="va">node</span>.<span class="at">callee</span>)</a>
<a class="sourceLine" id="cb9-49" title="49">          <span class="op">&amp;&amp;</span> <span class="va">node</span>.<span class="va">callee</span>.<span class="at">name</span> <span class="op">===</span> <span class="st">&quot;super&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-50" title="50">    <span class="op">},</span></a>
<a class="sourceLine" id="cb9-51" title="51"></a>
<a class="sourceLine" id="cb9-52" title="52">    <span class="at">isSuperMemberExpression</span>(node) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-53" title="53">      <span class="cf">return</span> <span class="va">n</span>.<span class="va">MemberExpression</span>.<span class="at">check</span>(<span class="va">node</span>.<span class="at">callee</span>)</a>
<a class="sourceLine" id="cb9-54" title="54">          <span class="op">&amp;&amp;</span> <span class="va">n</span>.<span class="va">Identifier</span>.<span class="at">check</span>(<span class="va">node</span>.<span class="va">callee</span>.<span class="at">object</span>)</a>
<a class="sourceLine" id="cb9-55" title="55">          <span class="op">&amp;&amp;</span> <span class="va">node</span>.<span class="va">callee</span>.<span class="va">object</span>.<span class="at">name</span> <span class="op">===</span> <span class="st">&quot;super&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-56" title="56">    <span class="op">}</span></a>
<a class="sourceLine" id="cb9-57" title="57">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-58" title="58"></a>
<a class="sourceLine" id="cb9-59" title="59">  <span class="cf">return</span> result<span class="op">;</span></a>
<a class="sourceLine" id="cb9-60" title="60"><span class="op">}</span></a></code></pre></div>
<p>As you might guess, when an <code>AbortRequest</code> is thrown from a subtree, the exception will propagate from the corresponding calls to <code>this.traverse</code> in the ancestor visitor methods. If you decide you want to cancel the request, simply catch the exception and call its <code>.cancel()</code> method. The rest of the subtree beneath the <code>try</code>-<code>catch</code> block will be abandoned, but the remaining siblings of the ancestor node will still be visited.</p>
<h2 id="nodepath">NodePath</h2>
<p>The <code>NodePath</code> object passed to visitor methods is a wrapper around an AST node, and it serves to provide access to the chain of ancestor objects (all the way back to the root of the AST) and scope information.</p>
<p>In general, <code>path.node</code> refers to the wrapped node, <code>path.parent.node</code> refers to the nearest <code>Node</code> ancestor, <code>path.parent.parent.node</code> to the grandparent, and so on.</p>
<p>Note that <code>path.node</code> may not be a direct property value of <code>path.parent.node</code>; for instance, it might be the case that <code>path.node</code> is an element of an array that is a direct child of the parent node:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="va">path</span>.<span class="at">node</span> <span class="op">===</span> <span class="va">path</span>.<span class="va">parent</span>.<span class="va">node</span>.<span class="at">elements</span>[<span class="dv">3</span>]</a></code></pre></div>
<p>in which case you should know that <code>path.parentPath</code> provides finer-grained access to the complete path of objects (not just the <code>Node</code> ones) from the root of the AST:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="co">// In reality, path.parent is the grandparent of path:</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="va">path</span>.<span class="va">parentPath</span>.<span class="at">parentPath</span> <span class="op">===</span> <span class="va">path</span>.<span class="at">parent</span></a>
<a class="sourceLine" id="cb11-3" title="3"></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="co">// The path.parentPath object wraps the elements array (note that we use</span></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="co">// .value because the elements array is not a Node):</span></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="va">path</span>.<span class="va">parentPath</span>.<span class="at">value</span> <span class="op">===</span> <span class="va">path</span>.<span class="va">parent</span>.<span class="va">node</span>.<span class="at">elements</span></a>
<a class="sourceLine" id="cb11-7" title="7"></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="co">// The path.node object is the fourth element in that array:</span></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="va">path</span>.<span class="va">parentPath</span>.<span class="at">value</span>[<span class="dv">3</span>] <span class="op">===</span> <span class="va">path</span>.<span class="at">node</span></a>
<a class="sourceLine" id="cb11-10" title="10"></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="co">// Unlike path.node and path.value, which are synonyms because path.node</span></a>
<a class="sourceLine" id="cb11-12" title="12"><span class="co">// is a Node object, path.parentPath.node is distinct from</span></a>
<a class="sourceLine" id="cb11-13" title="13"><span class="co">// path.parentPath.value, because the elements array is not a</span></a>
<a class="sourceLine" id="cb11-14" title="14"><span class="co">// Node. Instead, path.parentPath.node refers to the closest ancestor</span></a>
<a class="sourceLine" id="cb11-15" title="15"><span class="co">// Node, which happens to be the same as path.parent.node:</span></a>
<a class="sourceLine" id="cb11-16" title="16"><span class="va">path</span>.<span class="va">parentPath</span>.<span class="at">node</span> <span class="op">===</span> <span class="va">path</span>.<span class="va">parent</span>.<span class="at">node</span></a>
<a class="sourceLine" id="cb11-17" title="17"></a>
<a class="sourceLine" id="cb11-18" title="18"><span class="co">// The path is named for its index in the elements array:</span></a>
<a class="sourceLine" id="cb11-19" title="19"><span class="va">path</span>.<span class="at">name</span> <span class="op">===</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb11-20" title="20"></a>
<a class="sourceLine" id="cb11-21" title="21"><span class="co">// Likewise, path.parentPath is named for the property by which</span></a>
<a class="sourceLine" id="cb11-22" title="22"><span class="co">// path.parent.node refers to it:</span></a>
<a class="sourceLine" id="cb11-23" title="23"><span class="va">path</span>.<span class="va">parentPath</span>.<span class="at">name</span> <span class="op">===</span> <span class="st">&quot;elements&quot;</span></a>
<a class="sourceLine" id="cb11-24" title="24"></a>
<a class="sourceLine" id="cb11-25" title="25"><span class="co">// Putting it all together, we can follow the chain of object references</span></a>
<a class="sourceLine" id="cb11-26" title="26"><span class="co">// from path.parent.node all the way to path.node by accessing each</span></a>
<a class="sourceLine" id="cb11-27" title="27"><span class="co">// property by name:</span></a>
<a class="sourceLine" id="cb11-28" title="28"><span class="va">path</span>.<span class="va">parent</span>.<span class="at">node</span>[<span class="va">path</span>.<span class="va">parentPath</span>.<span class="at">name</span>][<span class="va">path</span>.<span class="at">name</span>] <span class="op">===</span> <span class="va">path</span>.<span class="at">node</span></a></code></pre></div>
<p>These <code>NodePath</code> objects are created during the traversal without modifying the AST nodes themselves, so it’s not a problem if the same node appears more than once in the AST (like <code>Array.prototype.slice.call</code> in the example above), because it will be visited with a distict <code>NodePath</code> each time it appears.</p>
<p>Child <code>NodePath</code> objects are created lazily, by calling the <code>.get</code> method of a parent <code>NodePath</code> object:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="co">// If a NodePath object for the elements array has never been created</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co">// before, it will be created here and cached in the future:</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;elements&quot;</span>).<span class="at">get</span>(<span class="dv">3</span>).<span class="at">value</span> <span class="op">===</span> <span class="va">path</span>.<span class="va">value</span>.<span class="at">elements</span>[<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb12-4" title="4"></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co">// Alternatively, you can pass multiple property names to .get instead of</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="co">// chaining multiple .get calls:</span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;elements&quot;</span><span class="op">,</span> <span class="dv">0</span>).<span class="at">value</span> <span class="op">===</span> <span class="va">path</span>.<span class="va">value</span>.<span class="at">elements</span>[<span class="dv">0</span>]</a></code></pre></div>
<p><code>NodePath</code> objects support a number of useful methods:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="co">// Replace one node with another node:</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">var</span> fifth <span class="op">=</span> <span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;elements&quot;</span><span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="va">fifth</span>.<span class="at">replace</span>(newNode)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="co">// Now do some stuff that might rearrange the list, and this replacement</span></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="co">// remains safe:</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="va">fifth</span>.<span class="at">replace</span>(newerNode)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="co">// Replace the third element in an array with two new nodes:</span></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;elements&quot;</span><span class="op">,</span> <span class="dv">2</span>).<span class="at">replace</span>(</a>
<a class="sourceLine" id="cb13-11" title="11">  <span class="va">b</span>.<span class="at">identifier</span>(<span class="st">&quot;foo&quot;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb13-12" title="12">  <span class="va">b</span>.<span class="at">thisExpression</span>()</a>
<a class="sourceLine" id="cb13-13" title="13">)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-14" title="14"></a>
<a class="sourceLine" id="cb13-15" title="15"><span class="co">// Remove a node and its parent if it would leave a redundant AST node:</span></a>
<a class="sourceLine" id="cb13-16" title="16"><span class="co">//e.g. var t = 1, y =2; removing the `t` and `y` declarators results in `var undefined`.</span></a>
<a class="sourceLine" id="cb13-17" title="17"><span class="va">path</span>.<span class="at">prune</span>()<span class="op">;</span> <span class="co">//returns the closest parent `NodePath`.</span></a>
<a class="sourceLine" id="cb13-18" title="18"></a>
<a class="sourceLine" id="cb13-19" title="19"><span class="co">// Remove a node from a list of nodes:</span></a>
<a class="sourceLine" id="cb13-20" title="20"><span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;elements&quot;</span><span class="op">,</span> <span class="dv">3</span>).<span class="at">replace</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb13-21" title="21"></a>
<a class="sourceLine" id="cb13-22" title="22"><span class="co">// Add three new nodes to the beginning of a list of nodes:</span></a>
<a class="sourceLine" id="cb13-23" title="23"><span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;elements&quot;</span>).<span class="at">unshift</span>(a<span class="op">,</span> b<span class="op">,</span> c)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-24" title="24"></a>
<a class="sourceLine" id="cb13-25" title="25"><span class="co">// Remove and return the first node in a list of nodes:</span></a>
<a class="sourceLine" id="cb13-26" title="26"><span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;elements&quot;</span>).<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb13-27" title="27"></a>
<a class="sourceLine" id="cb13-28" title="28"><span class="co">// Push two new nodes onto the end of a list of nodes:</span></a>
<a class="sourceLine" id="cb13-29" title="29"><span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;elements&quot;</span>).<span class="at">push</span>(d<span class="op">,</span> e)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-30" title="30"></a>
<a class="sourceLine" id="cb13-31" title="31"><span class="co">// Remove and return the last node in a list of nodes:</span></a>
<a class="sourceLine" id="cb13-32" title="32"><span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;elements&quot;</span>).<span class="at">pop</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb13-33" title="33"></a>
<a class="sourceLine" id="cb13-34" title="34"><span class="co">// Insert a new node before/after the seventh node in a list of nodes:</span></a>
<a class="sourceLine" id="cb13-35" title="35"><span class="kw">var</span> seventh <span class="op">=</span> <span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;elements&quot;</span><span class="op">,</span> <span class="dv">6</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-36" title="36"><span class="va">seventh</span>.<span class="at">insertBefore</span>(newNode)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-37" title="37"><span class="va">seventh</span>.<span class="at">insertAfter</span>(newNode)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-38" title="38"></a>
<a class="sourceLine" id="cb13-39" title="39"><span class="co">// Insert a new element at index 5 in a list of nodes:</span></a>
<a class="sourceLine" id="cb13-40" title="40"><span class="va">path</span>.<span class="at">get</span>(<span class="st">&quot;elements&quot;</span>).<span class="at">insertAt</span>(<span class="dv">5</span><span class="op">,</span> newNode)<span class="op">;</span></a></code></pre></div>
<h2 id="scope">Scope</h2>
<p>The object exposed as <code>path.scope</code> during AST traversals provides information about variable and function declarations in the scope that contains <code>path.node</code>. See <a href="lib/scope.ts">scope.ts</a> for its public interface, which currently includes <code>.isGlobal</code>, <code>.getGlobalScope()</code>, <code>.depth</code>, <code>.declares(name)</code>, <code>.lookup(name)</code>, and <code>.getBindings()</code>.</p>
<h2 id="custom-ast-node-types">Custom AST Node Types</h2>
<p>The <code>ast-types</code> module was designed to be extended. To that end, it provides a readable, declarative syntax for specifying new AST node types, based primarily upon the <code>require("ast-types").Type.def</code> function:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="im">import</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb14-2" title="2">  Type<span class="op">,</span></a>
<a class="sourceLine" id="cb14-3" title="3">  builtInTypes<span class="op">,</span></a>
<a class="sourceLine" id="cb14-4" title="4">  builders <span class="im">as</span> b<span class="op">,</span></a>
<a class="sourceLine" id="cb14-5" title="5">  finalize<span class="op">,</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="op">}</span> <span class="im">from</span> <span class="st">&quot;ast-types&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb14-7" title="7"></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="kw">const</span> <span class="op">{</span> def <span class="op">}</span> <span class="op">=</span> Type<span class="op">;</span></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="kw">const</span> <span class="op">{</span> string <span class="op">}</span> <span class="op">=</span> builtInTypes<span class="op">;</span></a>
<a class="sourceLine" id="cb14-10" title="10"></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="co">// Suppose you need a named File type to wrap your Programs.</span></a>
<a class="sourceLine" id="cb14-12" title="12"><span class="at">def</span>(<span class="st">&quot;File&quot;</span>)</a>
<a class="sourceLine" id="cb14-13" title="13">  .<span class="at">bases</span>(<span class="st">&quot;Node&quot;</span>)</a>
<a class="sourceLine" id="cb14-14" title="14">  .<span class="at">build</span>(<span class="st">&quot;name&quot;</span><span class="op">,</span> <span class="st">&quot;program&quot;</span>)</a>
<a class="sourceLine" id="cb14-15" title="15">  .<span class="at">field</span>(<span class="st">&quot;name&quot;</span><span class="op">,</span> string)</a>
<a class="sourceLine" id="cb14-16" title="16">  .<span class="at">field</span>(<span class="st">&quot;program&quot;</span><span class="op">,</span> <span class="at">def</span>(<span class="st">&quot;Program&quot;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb14-17" title="17"></a>
<a class="sourceLine" id="cb14-18" title="18"><span class="co">// Prevent further modifications to the File type (and any other</span></a>
<a class="sourceLine" id="cb14-19" title="19"><span class="co">// types newly introduced by def(...)).</span></a>
<a class="sourceLine" id="cb14-20" title="20"><span class="at">finalize</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb14-21" title="21"></a>
<a class="sourceLine" id="cb14-22" title="22"><span class="co">// The b.file builder function is now available. It expects two</span></a>
<a class="sourceLine" id="cb14-23" title="23"><span class="co">// arguments, as named by .build(&quot;name&quot;, &quot;program&quot;) above.</span></a>
<a class="sourceLine" id="cb14-24" title="24"><span class="kw">const</span> main <span class="op">=</span> <span class="va">b</span>.<span class="at">file</span>(<span class="st">&quot;main.js&quot;</span><span class="op">,</span> <span class="va">b</span>.<span class="at">program</span>([</a>
<a class="sourceLine" id="cb14-25" title="25">  <span class="co">// Pointless program contents included for extra color.</span></a>
<a class="sourceLine" id="cb14-26" title="26">  <span class="va">b</span>.<span class="at">functionDeclaration</span>(<span class="va">b</span>.<span class="at">identifier</span>(<span class="st">&quot;succ&quot;</span>)<span class="op">,</span> [</a>
<a class="sourceLine" id="cb14-27" title="27">    <span class="va">b</span>.<span class="at">identifier</span>(<span class="st">&quot;x&quot;</span>)</a>
<a class="sourceLine" id="cb14-28" title="28">  ]<span class="op">,</span> <span class="va">b</span>.<span class="at">blockStatement</span>([</a>
<a class="sourceLine" id="cb14-29" title="29">    <span class="va">b</span>.<span class="at">returnStatement</span>(</a>
<a class="sourceLine" id="cb14-30" title="30">      <span class="va">b</span>.<span class="at">binaryExpression</span>(</a>
<a class="sourceLine" id="cb14-31" title="31">        <span class="st">&quot;+&quot;</span><span class="op">,</span> <span class="va">b</span>.<span class="at">identifier</span>(<span class="st">&quot;x&quot;</span>)<span class="op">,</span> <span class="va">b</span>.<span class="at">literal</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb14-32" title="32">      )</a>
<a class="sourceLine" id="cb14-33" title="33">    )</a>
<a class="sourceLine" id="cb14-34" title="34">  ]))</a>
<a class="sourceLine" id="cb14-35" title="35">]))<span class="op">;</span></a>
<a class="sourceLine" id="cb14-36" title="36"></a>
<a class="sourceLine" id="cb14-37" title="37"><span class="va">assert</span>.<span class="at">strictEqual</span>(<span class="va">main</span>.<span class="at">name</span><span class="op">,</span> <span class="st">&quot;main.js&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-38" title="38"><span class="va">assert</span>.<span class="at">strictEqual</span>(<span class="va">main</span>.<span class="va">program</span>.<span class="at">body</span>[<span class="dv">0</span>].<span class="at">params</span>[<span class="dv">0</span>].<span class="at">name</span><span class="op">,</span> <span class="st">&quot;x&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-39" title="39"><span class="co">// etc.</span></a>
<a class="sourceLine" id="cb14-40" title="40"></a>
<a class="sourceLine" id="cb14-41" title="41"><span class="co">// If you pass the wrong type of arguments, or fail to pass enough</span></a>
<a class="sourceLine" id="cb14-42" title="42"><span class="co">// arguments, an AssertionError will be thrown.</span></a>
<a class="sourceLine" id="cb14-43" title="43"></a>
<a class="sourceLine" id="cb14-44" title="44"><span class="va">b</span>.<span class="at">file</span>(<span class="va">b</span>.<span class="at">blockStatement</span>([]))<span class="op">;</span></a>
<a class="sourceLine" id="cb14-45" title="45"><span class="co">// ==&gt; AssertionError: {&quot;body&quot;:[],&quot;type&quot;:&quot;BlockStatement&quot;,&quot;loc&quot;:null} does not match type string</span></a>
<a class="sourceLine" id="cb14-46" title="46"></a>
<a class="sourceLine" id="cb14-47" title="47"><span class="va">b</span>.<span class="at">file</span>(<span class="st">&quot;lib/types.js&quot;</span><span class="op">,</span> <span class="va">b</span>.<span class="at">thisExpression</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb14-48" title="48"><span class="co">// ==&gt; AssertionError: {&quot;type&quot;:&quot;ThisExpression&quot;,&quot;loc&quot;:null} does not match type Program</span></a></code></pre></div>
<p>The <code>def</code> syntax is used to define all the default AST node types found in <a href="def/babel-core.ts">babel-core.ts</a>, <a href="def/babel.ts">babel.ts</a>, <a href="def/core.ts">core.ts</a>, <a href="def/es-proposals.ts">es-proposals.ts</a>, <a href="def/es6.ts">es6.ts</a>, <a href="def/es7.ts">es7.ts</a>, <a href="def/es2020.ts">es2020.ts</a>, <a href="def/esprima.ts">esprima.ts</a>, <a href="def/flow.ts">flow.ts</a>, <a href="def/jsx.ts">jsx.ts</a>, <a href="def/type-annotations.ts">type-annotations.ts</a>, and <a href="def/typescripts.ts">typescripts.ts</a>, so you have no shortage of examples to learn from.</p>
</body>
</html>
