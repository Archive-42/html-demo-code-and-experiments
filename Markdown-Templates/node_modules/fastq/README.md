fastq
=====

![ci](https://github.com/mcollina/fastq/workflows/ci/badge.svg) [![npm version](https://badge.fury.io/js/fastq.svg)](https://badge.fury.io/js/fastq) [![Dependency Status](https://david-dm.org/mcollina/fastq.svg)](https://david-dm.org/mcollina/fastq)

Fast, in memory work queue.

Benchmarks (1 million tasks):

-   setImmediate: 812ms
-   fastq: 854ms
-   async.queue: 1298ms
-   neoAsync.queue: 1249ms

Obtained on node 12.16.1, on a dedicated server.

If you need zero-overhead series function call, check out [fastseries](http://npm.im/fastseries). For zero-overhead parallel function call, check out [fastparallel](http://npm.im/fastparallel).

[![js-standard-style](https://raw.githubusercontent.com/feross/standard/master/badge.png)](https://github.com/feross/standard)

-   [Installation](#install)
-   [Usage](#usage)
-   [API](#api)
-   [Licence & copyright](#license)

Install
-------

`npm i fastq --save`

Usage
-----

    'use strict'

    var queue = require('fastq')(worker, 1)

    queue.push(42, function (err, result) {
      if (err) { throw err }
      console.log('the result is', result)
    })

    function worker (arg, cb) {
      cb(null, 42 * 2)
    }

or

    var queue = require('fastq').promise(worker, 1)

    async function worker (arg) {
      return 42 * 2
    }

    async function run () {
      const result = await queue.push(42)
      console.log('the result is', result)
    })
    }

    run()

### Setting this

    'use strict'

    var that = { hello: 'world' }
    var queue = require('fastq')(that, worker, 1)

    queue.push(42, function (err, result) {
      if (err) { throw err }
      console.log(this)
      console.log('the result is', result)
    })

    function worker (arg, cb) {
      console.log(this)
      cb(null, 42 * 2)
    }

API
---

-   [`fastqueue()`](#fastqueue)
-   [`queue#push()`](#push)
-   [`queue#unshift()`](#unshift)
-   [`queue#pause()`](#pause)
-   [`queue#resume()`](#resume)
-   [`queue#idle()`](#idle)
-   [`queue#length()`](#length)
-   [`queue#getQueue()`](#getQueue)
-   [`queue#kill()`](#kill)
-   [`queue#killAndDrain()`](#killAndDrain)
-   [`queue#error()`](#error)
-   [`queue#concurrency`](#concurrency)
-   [`queue#drain`](#drain)
-   [`queue#empty`](#empty)
-   [`queue#saturated`](#saturated)
-   [`fastqueue.promise()`](#promise)

<table style="width:77%;"><colgroup><col style="width: 77%" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><span id="fastqueue"></span> ### fastqueue([that], worker, concurrency)</td></tr><tr class="even"><td style="text-align: left;">Creates a new queue.</td></tr><tr class="odd"><td style="text-align: left;">Arguments:</td></tr><tr class="even"><td style="text-align: left;">* <code>that</code>, optional context of the <code>worker</code> function. * <code>worker</code>, worker function, it would be called with <code>that</code> as <code>this</code>, if that is specified. * <code>concurrency</code>, number of concurrent tasks that could be executed in parallel.</td></tr></tbody></table>

<span id="push"></span> \#\#\# queue.push(task, done)

Add a task at the end of the queue. `done(err, result)` will be called when the task was processed.

<table style="width:77%;"><colgroup><col style="width: 77%" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><span id="unshift"></span> ### queue.unshift(task, done)</td></tr><tr class="even"><td style="text-align: left;">Add a task at the beginning of the queue. <code>done(err, result)</code> will be called when the task was processed.</td></tr></tbody></table>

<span id="pause"></span> \#\#\# queue.pause()

Pause the processing of tasks. Currently worked tasks are not stopped.

<table style="width:77%;"><colgroup><col style="width: 77%" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><span id="resume"></span> ### queue.resume()</td></tr><tr class="even"><td style="text-align: left;">Resume the processing of tasks.</td></tr></tbody></table>

<span id="idle"></span> \#\#\# queue.idle()

Returns `false` if there are tasks being processed or waiting to be processed. `true` otherwise.

<table style="width:77%;"><colgroup><col style="width: 77%" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><span id="length"></span> ### queue.length()</td></tr><tr class="even"><td style="text-align: left;">Returns the number of tasks waiting to be processed (in the queue).</td></tr></tbody></table>

<span id="getQueue"></span> \#\#\# queue.getQueue()

Returns all the tasks be processed (in the queue). Returns empty array when there are no tasks

<table style="width:77%;"><colgroup><col style="width: 77%" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><span id="kill"></span> ### queue.kill()</td></tr><tr class="even"><td style="text-align: left;">Removes all tasks waiting to be processed, and reset <code>drain</code> to an empty function.</td></tr></tbody></table>

<span id="killAndDrain"></span> \#\#\# queue.killAndDrain()

Same than `kill` but the `drain` function will be called before reset to empty.

<table style="width:77%;"><colgroup><col style="width: 77%" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><span id="error"></span> ### queue.error(handler)</td></tr><tr class="even"><td style="text-align: left;">Set a global error handler. <code>handler(err, task)</code> will be called when any of the tasks return an error.</td></tr></tbody></table>

<span id="concurrency"></span> \#\#\# queue.concurrency

Property that returns the number of concurrent tasks that could be executed in parallel. It can be altered at runtime.

<table style="width:77%;"><colgroup><col style="width: 77%" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><span id="drain"></span> ### queue.drain</td></tr><tr class="even"><td style="text-align: left;">Function that will be called when the last item from the queue has been processed by a worker. It can be altered at runtime.</td></tr></tbody></table>

<span id="empty"></span> \#\#\# queue.empty

Function that will be called when the last item from the queue has been assigned to a worker. It can be altered at runtime.

<table style="width:77%;"><colgroup><col style="width: 77%" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><span id="saturated"></span> ### queue.saturated</td></tr><tr class="even"><td style="text-align: left;">Function that will be called when the queue hits the concurrency limit. It can be altered at runtime.</td></tr></tbody></table>

<span id="promise"></span> \#\#\# fastqueue.promise(\[that\], worker(arg), concurrency)

Creates a new queue with `Promise` apis. It also offers all the methods and properties of the object returned by [`fastqueue`](#fastqueue) with the modified [`push`](#pushPromise) and [`unshift`](#unshiftPromise) methods.

Node v10+ is required to use the promisified version.

Arguments: \* `that`, optional context of the `worker` function. \* `worker`, worker function, it would be called with `that` as `this`, if that is specified. It MUST return a `Promise`. \* `concurrency`, number of concurrent tasks that could be executed in parallel.

<span id="pushPromise"></span> \#\#\#\# queue.push(task) =&gt; Promise

Add a task at the end of the queue. The returned `Promise` will be fulfilled when the task is processed.

<span id="unshiftPromise"></span> \#\#\#\# queue.unshift(task) =&gt; Promise

Add a task at the beginning of the queue. The returned `Promise` will be fulfilled when the task is processed.

License
-------

ISC
